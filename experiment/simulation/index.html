<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Metal-Semiconductor Junction Virtual Lab</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #f8fafc, #e2e8f0, #cbd5e1);
            min-height: 100vh;
            color: #1e293b;
            overflow-x: hidden;
            position: relative;
            padding-bottom: 20px;
        }

        /* Animated background particles */
        .bg-particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: -1;
        }

        .particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            animation: float 6s ease-in-out infinite;
            box-shadow: 0 0 8px rgba(255, 255, 255, 0.5);
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px) rotate(0deg); opacity: 0.6; }
            50% { transform: translateY(-20px) rotate(180deg); opacity: 1; }
        }

        /* Main container */
        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 15px;
            min-height: 100vh;
        }

        /* Header */
        .header {
            text-align: center;
            padding: 40px 20px;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.9), rgba(248, 250, 252, 0.8));
            border-radius: 20px;
            margin-bottom: 30px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.8);
            box-shadow: 0 8px 32px rgba(255, 255, 255, 0.2);
        }

        .header h1 {
            font-size: 3rem;
            font-weight: 800;
            background: linear-gradient(135deg, #667eea, #764ba2, #6366f1);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
            animation: glow 2s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from { filter: drop-shadow(0 0 20px rgba(102, 126, 234, 0.8)); }
            to { filter: drop-shadow(0 0 30px rgba(118, 75, 162, 1)); }
        }

        .header p {
            font-size: 1.2rem;
            opacity: 0.8;
            font-weight: 400;
            color: #764ba2;
        }

        /* Navigation tabs */
        .nav-tabs {
            display: flex;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 12px;
            padding: 6px;
            margin-bottom: 20px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.95);
            box-shadow: 0 6px 25px rgba(255, 255, 255, 0.3);
            flex-wrap: wrap;
        }

        .nav-tab {
            flex: 1;
            min-width: 160px;
            padding: 10px 15px;
            text-align: center;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            font-size: 0.9em;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            position: relative;
            overflow: hidden;
        }

        .nav-tab::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }

        .nav-tab:hover::before {
            left: 100%;
        }

        .nav-tab.active {
            background: linear-gradient(135deg, #ffffff, #f8fafc);
            color: #6366f1;
            box-shadow: 0 6px 20px rgba(255, 255, 255, 0.6);
            transform: translateY(-1px);
            border: 2px solid rgba(255, 255, 255, 0.8);
        }

        .nav-tab:not(.active) {
            color: #9ca3af;
        }

        /* Main content area */
        .content-area {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
            min-height: calc(100vh - 250px);
            align-items: start;
        }

        .simulation-panel {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 20px;
            padding: 30px;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
        }

        .simulation-panel::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, #6366f1, #8b5cf6, #ec4899);
        }

        .controls-panel {
            background: rgba(255, 255, 255, 0.9);
            border-radius: 20px;
            padding: 20px;
            backdrop-filter: blur(15px);
            border: 2px solid rgba(255, 255, 255, 0.95);
            height: auto;
            min-height: fit-content;
            max-height: none;
            position: relative;
            box-shadow: 0 8px 32px rgba(255, 255, 255, 0.3);
            overflow-y: visible;
        }

        .controls-panel::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, #e2e8f0, #f8fafc, #ffffff);
        }

        .panel-title {
            font-size: 1.25rem;
            font-weight: 700;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
            color: #6366f1;
        }

        /* Controls */
        .control-group {
            margin-bottom: 12px;
            padding: 12px 15px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 10px;
            border: 2px solid rgba(139, 92, 246, 0.3);
            transition: all 0.3s ease;
            box-shadow: 0 4px 16px rgba(139, 92, 246, 0.1);
        }

        .control-group:hover {
            background: rgba(255, 255, 255, 1);
            border-color: rgba(99, 102, 241, 0.5);
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(139, 92, 246, 0.2);
        }

        .control-label {
            display: block;
            font-weight: 600;
            margin-bottom: 5px;
            color: #8b5cf6;
            font-size: 0.9rem;
        }

        .control-value {
            font-weight: 700;
            color: #6366f1;
            font-size: 0.95rem;
        }

        /* Custom slider */
        .slider {
            width: 100%;
            height: 6px;
            border-radius: 5px;
            background: linear-gradient(to right, #ede9fe, #f1f5f9, #ddd6fe);
            outline: none;
            margin: 8px 0;
            -webkit-appearance: none;
            appearance: none;
            border: 1px solid rgba(99, 102, 241, 0.2);
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: linear-gradient(135deg, #6366f1, #8b5cf6);
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(99, 102, 241, 0.4);
            transition: all 0.3s ease;
            border: 2px solid rgba(255, 255, 255, 0.9);
        }

        .slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 6px 20px rgba(99, 102, 241, 0.6);
        }

        .slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: linear-gradient(135deg, #6366f1, #8b5cf6);
            cursor: pointer;
            border: 2px solid rgba(255, 255, 255, 0.9);
            box-shadow: 0 4px 15px rgba(99, 102, 241, 0.4);
        }

        /* Custom select */
        .custom-select {
            width: 100%;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.9);
            border: 2px solid rgba(255, 255, 255, 0.95);
            border-radius: 8px;
            color: #8b5cf6;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
        }

        .custom-select:hover, .custom-select:focus {
            border-color: #6366f1;
            background: rgba(255, 255, 255, 1);
            outline: none;
            box-shadow: 0 4px 16px rgba(255, 255, 255, 0.4);
        }

        /* Buttons */
        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            font-family: inherit;
            position: relative;
            overflow: hidden;
            margin: 3px;
            font-size: 0.85rem;
        }

        .btn-primary {
            background: linear-gradient(135deg, #6366f1, #8b5cf6);
            color: white;
            box-shadow: 0 4px 15px rgba(99, 102, 241, 0.3);
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(99, 102, 241, 0.5);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.8);
            color: #8b5cf6;
            border: 2px solid rgba(255, 255, 255, 0.9);
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 1);
            transform: translateY(-2px);
            box-shadow: 0 4px 16px rgba(255, 255, 255, 0.4);
        }

        /* Visualization canvas */
        .visualization-canvas {
            width: 100%;
            height: 500px;
            background: 
                radial-gradient(circle at 25% 25%, rgba(99, 102, 241, 0.12) 0%, transparent 45%),
                radial-gradient(circle at 75% 75%, rgba(139, 92, 246, 0.10) 0%, transparent 45%),
                radial-gradient(circle at 50% 10%, rgba(124, 58, 237, 0.08) 0%, transparent 40%),
                linear-gradient(135deg, 
                    rgba(249, 250, 251, 1) 0%, 
                    rgba(243, 244, 246, 0.98) 20%, 
                    rgba(255, 255, 255, 1) 40%, 
                    rgba(245, 243, 255, 0.95) 60%, 
                    rgba(237, 233, 254, 0.92) 80%, 
                    rgba(228, 228, 231, 0.9) 100%
                );
            border-radius: 15px;
            border: 1px solid rgba(99, 102, 241, 0.15);
            position: relative;
            overflow: hidden;
            box-shadow: 
                inset 0 1px 25px rgba(255, 255, 255, 0.7),
                inset 0 -1px 15px rgba(139, 92, 246, 0.05),
                0 4px 25px rgba(99, 102, 241, 0.1),
                0 8px 40px rgba(124, 58, 237, 0.06);
        }

        /* Measurements */
        .measurements {
            background: rgba(255, 255, 255, 0.8);
            border-radius: 12px;
            padding: 12px 15px;
            margin-top: 15px;
            border: 2px solid rgba(255, 255, 255, 0.9);
            box-shadow: 0 4px 16px rgba(255, 255, 255, 0.2);
        }

        .measurement-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 0;
            border-bottom: 2px solid rgba(99, 102, 241, 0.1);
        }

        .measurement-item:last-child {
            border-bottom: none;
        }

        .measurement-label {
            font-weight: 500;
            color: #8b5cf6;
            font-size: 0.85rem;
        }

        .measurement-value {
            font-weight: 700;
            color: #6366f1;
            font-size: 0.85rem;
        }

        /* H4 headings in measurements */
        .measurements h4 {
            color: #6366f1;
            font-weight: 600;
            margin-bottom: 8px;
            font-size: 1rem;
        }

        /* Tab content */
        .tab-content {
            display: none;
            animation: fadeIn 0.5s ease-in-out;
        }

        .tab-content.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Help floating button */
        .help-btn {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, #6366f1, #8b5cf6);
            border: 2px solid rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            color: white;
            font-size: 24px;
            cursor: pointer;
            box-shadow: 0 8px 25px rgba(99, 102, 241, 0.4);
            transition: all 0.3s ease;
            z-index: 1000;
        }

        .help-btn:hover {
            transform: translateY(-5px) scale(1.1);
            box-shadow: 0 15px 35px rgba(99, 102, 241, 0.6);
        }

        /* Floating action buttons & panels */
        .floating-button {
            position: fixed;
            width: 3.5rem;
            height: 3.5rem;
            border-radius: 50%;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
        }

        .floating-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 14px rgba(0,0,0,0.25);
        }

        .floating-button:active {
            transform: translateY(-1px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }

        .floating-button.tour {
            background: linear-gradient(135deg, #10b981, #059669);
            color: white;
            bottom: 6.5rem;
            right: 2rem;
        }

        /* GUIDED TOUR STYLES */
        .tour-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: transparent;
            z-index: 200;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .tour-overlay.active {
            opacity: 1;
            pointer-events: none; /* Allow interaction with background */
        }

        .tour-spotlight {
            position: absolute;
            background: transparent;
            border: 3px solid #10b981;
            border-radius: 12px;
            box-shadow: 0 0 0 2px rgba(16, 185, 129, 0.2), 0 0 20px rgba(16, 185, 129, 0.3);
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 201;
            animation: spotlight-pulse 2s infinite;
            pointer-events: none; /* Allow clicks to pass through */
        }

        @keyframes spotlight-pulse {
            0%, 100% {
                border-color: #10b981;
                box-shadow: 0 0 0 2px rgba(16, 185, 129, 0.2), 0 0 20px rgba(16, 185, 129, 0.3);
            }
            50% {
                border-color: #34d399;
                box-shadow: 0 0 0 2px rgba(52, 211, 153, 0.3), 0 0 30px rgba(52, 211, 153, 0.5);
            }
        }

        .tour-spotlight-secondary {
            position: absolute;
            background: transparent;
            border: 2px solid #f59e0b;
            border-radius: 8px;
            box-shadow: 0 0 15px rgba(245, 158, 11, 0.5);
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 201;
            animation: secondary-pulse 1.5s infinite;
            pointer-events: none; /* Allow clicks to pass through */
        }

        @keyframes secondary-pulse {
            0%, 100% {
                border-color: #f59e0b;
                box-shadow: 0 0 15px rgba(245, 158, 11, 0.5);
            }
            50% {
                border-color: #fbbf24;
                box-shadow: 0 0 25px rgba(251, 191, 36, 0.7);
            }
        }

        .tour-popup {
            position: fixed;
            max-width: 380px;
            min-width: 320px;
            max-height: 90vh; /* Ensure popup doesn't exceed viewport height */
            background: white;
            border-radius: 16px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.2);
            z-index: 202;
            transform: scale(0.8) translateY(20px);
            opacity: 0;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            padding: 0;
            overflow: hidden;
            pointer-events: all; /* Ensure popup is clickable */
            /* Ensure popup stays within viewport bounds */
            margin: 10px;
        }

        .tour-popup.active {
            transform: scale(1) translateY(0);
            opacity: 1;
        }

        .tour-header {
            background: linear-gradient(135deg, #6366f1, #8b5cf6);
            color: white;
            padding: 20px;
            position: relative;
        }

        .tour-step-number {
            position: absolute;
            top: 15px;
            right: 20px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            padding: 5px 12px;
            font-size: 0.8rem;
            font-weight: 600;
        }

        .tour-title {
            font-size: 1.2rem;
            font-weight: 700;
            margin: 0;
            padding-right: 60px;
        }

        .tour-content {
            padding: 20px;
            line-height: 1.6;
            color: #374151;
            max-height: 60vh; /* Limit content height */
            overflow-y: auto; /* Make content scrollable if needed */
        }

        .tour-challenge {
            background: #f8fafc;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 20px;
            border-left: 4px solid #10b981;
        }

        .tour-challenge-title {
            font-weight: 600;
            color: #1f2937;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
        }

        .tour-challenge-title i {
            margin-right: 8px;
            color: #10b981;
        }

        .tour-challenge-content {
            color: #6b7280;
            font-size: 0.9rem;
        }

        .tour-progress {
            height: 4px;
            background: #e5e7eb;
            margin: 0 20px;
        }

        .tour-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #10b981, #34d399);
            border-radius: 2px;
            transition: width 0.5s ease;
        }

        .tour-controls {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-top: 1px solid #e5e7eb;
            gap: 10px;
            flex-wrap: wrap;
        }

        .tour-controls .tour-btn {
            flex: 0 1 auto;
        }

        .tour-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.9rem;
        }

        .tour-btn-primary {
            background: linear-gradient(135deg, #6366f1, #8b5cf6);
            color: white;
        }

        .tour-btn-secondary {
            background: #f3f4f6;
            color: #374151;
        }

        .tour-btn-skip {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            color: white;
            font-size: 0.8rem;
            padding: 8px 16px;
            opacity: 0.9;
            margin-left: auto;
        }

        .tour-btn-skip:hover {
            opacity: 1;
            background: linear-gradient(135deg, #dc2626, #b91c1c);
            transform: translateY(-1px);
        }

        .tour-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .tour-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .tour-score {
            position: fixed;
            top: 20px;
            right: 20px;
            background: white;
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
            z-index: 203;
            transform: translateY(-100px);
            opacity: 0;
            transition: all 0.3s ease;
        }

        .tour-score.active {
            transform: translateY(0);
            opacity: 1;
        }

        .tour-score-title {
            font-weight: 600;
            margin-bottom: 10px;
            color: #1f2937;
        }

        .tour-score-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 0.9rem;
            color: #6b7280;
        }

        .tour-achievements {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            background: white;
            border-radius: 16px;
            padding: 30px;
            text-align: center;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.2);
            z-index: 204;
            opacity: 0;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .tour-achievements.active {
            transform: translate(-50%, -50%) scale(1);
            opacity: 1;
        }

        .achievement-icon {
            font-size: 3rem;
            margin-bottom: 15px;
        }

        .achievement-title {
            font-size: 1.3rem;
            font-weight: 700;
            color: #1f2937;
            margin-bottom: 10px;
        }

        .achievement-description {
            color: #6b7280;
            margin-bottom: 20px;
        }

        .highlight-element {
            position: relative;
            z-index: 201;
            box-shadow: 0 0 25px rgba(16, 185, 129, 0.6), 0 0 40px rgba(16, 185, 129, 0.4) !important;
            border: 2px solid #10b981 !important;
            border-radius: 8px !important;
            animation: pulse-highlight 2s infinite;
            background: rgba(16, 185, 129, 0.05) !important;
        }

        @keyframes pulse-highlight {
            0%, 100% {
                box-shadow: 0 0 25px rgba(16, 185, 129, 0.6), 0 0 40px rgba(16, 185, 129, 0.4);
                transform: scale(1);
            }
            50% {
                box-shadow: 0 0 35px rgba(16, 185, 129, 0.8), 0 0 60px rgba(16, 185, 129, 0.6);
                transform: scale(1.02);
            }
        }

        .challenge-success {
            background: #10b981 !important;
            color: white !important;
            animation: celebration 0.6s ease;
        }

        @keyframes celebration {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        /* Responsive design */
        @media (max-width: 1024px) {
            .content-area {
                grid-template-columns: 1fr;
            }
            
            .nav-tabs {
                flex-direction: column;
            }
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 2rem;
            }
            
            .container {
                padding: 10px;
            }
            
            .nav-tab {
                min-width: unset;
            }
        }

        /* Junction visualization styles */
        .junction-region {
            position: absolute;
            border-radius: 10px;
            transition: all 0.5s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
        }

        .metal-region {
            background: linear-gradient(135deg, #6366f1, #8b5cf6);
            opacity: 0.8;
        }

        .semiconductor-region {
            background: linear-gradient(135deg, #10b981, #06b6d4);
            opacity: 0.8;
        }

        .depletion-region {
            background: linear-gradient(135deg, #f59e0b, #ef4444);
            opacity: 0.6;
        }

        .charge-carrier {
            position: absolute;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            transition: all 0.3s ease;
        }

        .electron {
            background: radial-gradient(circle, #60a5fa, #3b82f6);
            box-shadow: 0 0 10px rgba(59, 130, 246, 0.6);
        }

        .hole {
            background: radial-gradient(circle, #fb7185, #f43f5e);
            box-shadow: 0 0 10px rgba(244, 63, 94, 0.6);
        }

        /* Carrier animation */
        @keyframes carrierFloat {
            0%, 100% { transform: translate(0, 0); opacity: 1; }
            50% { transform: translate(10px, -5px); opacity: 0.7; }
        }

        .charge-carrier {
            animation: carrierFloat 3s ease-in-out infinite;
        }

        /* Canvas styling */
        canvas {
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.02);
        }

        /* Current flow animation */
        @keyframes currentFlow {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(300px); }
        }

        .current-arrow {
            animation: currentFlow 2s linear infinite;
        }

        /* Photon animation */
        @keyframes photonFall {
            0% { opacity: 0; transform: translateY(0); }
            50% { opacity: 1; }
            100% { opacity: 0; transform: translateY(40px); }
        }

        .photon {
            animation: photonFall 2s ease-in-out infinite;
        }

        /* CHALLENGE TAB STYLES */
        .challenge-container {
            background: white;
            border-radius: 16px;
            padding: 30px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        .challenge-section {
            margin-bottom: 40px;
            padding: 25px;
            border-radius: 12px;
            border: 2px solid #e5e7eb;
            transition: all 0.3s ease;
            background: #f8fafc;
        }

        .challenge-section:hover {
            border-color: #6366f1;
            box-shadow: 0 4px 20px rgba(99, 102, 241, 0.1);
        }

        .challenge-section.completed {
            border-color: #10b981;
            background: #f0fdf4;
        }

        .challenge-header {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
        }

        .challenge-icon {
            width: 60px;
            height: 60px;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            margin-right: 15px;
            background: linear-gradient(135deg, #6366f1, #8b5cf6);
            color: white;
        }

        .challenge-title {
            font-size: 1.3rem;
            font-weight: 600;
            color: #1f2937;
            margin: 0;
        }

        .challenge-description {
            color: #6b7280;
            margin-bottom: 20px;
            line-height: 1.6;
        }

        .quiz-question {
            background: #f8fafc;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            border-left: 4px solid #6366f1;
        }

        .quiz-question h4 {
            margin: 0 0 10px 0;
            color: #1f2937;
        }

        .quiz-options {
            display: grid;
            gap: 8px;
            margin-top: 10px;
        }

        .quiz-option {
            padding: 10px 15px;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            background: white;
        }

        .quiz-option:hover {
            border-color: #6366f1;
            background: #f8fafc;
        }

        .quiz-option.selected {
            border-color: #6366f1;
            background: #eff6ff;
            color: #1e40af;
        }

        .quiz-option.correct {
            border-color: #10b981;
            background: #f0fdf4;
            color: #065f46;
        }

        .quiz-option.incorrect {
            border-color: #ef4444;
            background: #fef2f2;
            color: #dc2626;
        }

        .fill-blank-container {
            background: #f8fafc;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            border-left: 4px solid #6366f1;
        }

        .fill-blank-text {
            line-height: 1.8;
            font-size: 1.1rem;
        }

        .fill-blank-input {
            display: inline-block;
            min-width: 80px;
            padding: 4px 8px;
            border: 2px solid #6366f1;
            border-radius: 4px;
            background: white;
            font-weight: 600;
            text-align: center;
            margin: 0 4px;
        }

        .fill-blank-input:focus {
            outline: none;
            border-color: #4f46e5;
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
        }

        .fill-blank-input.correct {
            border-color: #10b981;
            background: #f0fdf4;
            color: #065f46;
        }

        .fill-blank-input.incorrect {
            border-color: #ef4444;
            background: #fef2f2;
            color: #dc2626;
        }

        .matching-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
            position: relative;
        }

        .matching-lines-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 3;
        }

        .connection-line {
            stroke: #6366f1;
            stroke-width: 2;
            stroke-dasharray: 5,5;
            animation: dash 1s linear infinite;
        }

        .connection-line.correct {
            stroke: #10b981;
            stroke-width: 3;
            stroke-dasharray: none;
            animation: none;
        }

        .connection-line.incorrect {
            stroke: #ef4444;
            stroke-width: 3;
            stroke-dasharray: none;
            animation: none;
        }

        @keyframes dash {
            to {
                stroke-dashoffset: -10;
            }
        }
        
        .matching-column {
            background: #f8fafc;
            border-radius: 8px;
            padding: 15px;
            border: 2px solid #e5e7eb;
            position: relative;
            z-index: 1;
        }
        
        .matching-item {
            padding: 12px;
            margin: 8px 0;
            background: white;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            z-index: 4;
        }
        
        .matching-item:hover {
            border-color: #6366f1;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }
        
        .matching-item.selected {
            border-color: #6366f1;
            background: #eff6ff;
            color: #1e40af;
            box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.2);
        }
        
        .matching-item.matched {
            border-color: #6366f1;
            background: white;
            color: #1e293b;
            position: relative;
        }
        
        .matching-item.correct-match {
            border-color: #10b981;
            background: #f0fdf4;
            color: #065f46;
        }
        
        .matching-item.incorrect-match {
            border-color: #ef4444;
            background: #fef2f2;
            color: #dc2626;
        }

        .challenge-controls {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .challenge-btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: inherit;
            font-size: 0.9rem;
        }

        .challenge-btn-primary {
            background: linear-gradient(135deg, #6366f1, #8b5cf6);
            color: white;
        }

        .challenge-btn-secondary {
            background: #f3f4f6;
            color: #374151;
            border: 2px solid #e5e7eb;
        }

        .challenge-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .challenge-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .challenge-feedback {
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            font-weight: 500;
            display: none;
        }

        .challenge-feedback.success {
            background: #f0fdf4;
            color: #166534;
            border-left: 4px solid #16a34a;
        }

        .challenge-feedback.error {
            background: #fef2f2;
            color: #dc2626;
            border-left: 4px solid #ef4444;
        }

        .challenge-progress {
            background: #f1f5f9;
            border-radius: 10px;
            height: 8px;
            margin: 20px 0;
            overflow: hidden;
        }

        .challenge-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #6366f1, #8b5cf6);
            border-radius: 10px;
            transition: width 0.3s ease;
            width: 0%;
        }

        .challenge-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
            margin: 20px 0;
            padding: 20px;
            background: #f8fafc;
            border-radius: 12px;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: #1f2937;
        }

        .stat-label {
            font-size: 0.8rem;
            color: #6b7280;
            margin-top: 4px;
        }

        .challenge-hint {
            background: #fffbeb;
            border-left: 4px solid #f59e0b;
            padding: 15px;
            margin-top: 15px;
            border-radius: 8px;
            display: none;
        }

        .challenge-hint.active {
            display: block;
            animation: slideDown 0.3s ease;
        }

        .explanation-panel {
            background: #f0f9ff;
            border-left: 4px solid #0ea5e9;
            padding: 15px;
            margin-top: 15px;
            border-radius: 8px;
            display: none;
        }

        .explanation-panel.active {
            display: block;
            animation: slideDown 0.3s ease;
        }

        @keyframes slideDown {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .question-explanation {
            background: #f0f9ff;
            border: 1px solid #0ea5e9;
            border-radius: 8px;
            padding: 15px;
            margin-top: 10px;
            display: none;
        }

        .question-explanation.active {
            display: block;
            animation: slideDown 0.3s ease;
        }

        .answer-key {
            background: #f0f9ff;
            border: 2px solid #0ea5e9;
            border-radius: 12px;
            padding: 20px;
            margin-top: 20px;
            display: none;
        }

        .answer-key.active {
            display: block;
            animation: slideDown 0.3s ease;
        }

        .answer-key h4 {
            color: #0ea5e9;
            margin-bottom: 15px;
            font-size: 1.1rem;
        }

        .answer-pair {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 15px;
            align-items: center;
            padding: 10px;
            margin: 8px 0;
            background: white;
            border-radius: 8px;
            border-left: 4px solid #0ea5e9;
        }

        .answer-term, .answer-definition {
            font-weight: 500;
            color: #1e293b;
        }

        .answer-arrow {
            color: #0ea5e9;
            font-weight: bold;
            text-align: center;
        }

        .concept-box {
            background: linear-gradient(135deg, #eff6ff, #dbeafe);
            border: 2px solid #3b82f6;
            border-radius: 12px;
            padding: 20px;
            margin: 15px 0;
        }

        @media (max-width: 768px) {
            .challenge-container {
                padding: 20px;
            }
            
            .challenge-section {
                padding: 15px;
            }
            
            .matching-container {
                grid-template-columns: 1fr;
            }
            
            .challenge-stats {
                grid-template-columns: repeat(2, 1fr);
            }
        }
    </style>
</head>
<body>
    <!-- Mobile Detection Script -->
    <script>
        // Mobile Detection and Overlay Script - Modified for Metal-Semiconductor Junction Lab
        // This script detects mobile devices and shows a desktop optimization warning

        class MobileDetection {
          constructor() {
            this.isMobile = this.detectMobile();
            this.overlayShown = false;
            this.walkthroughDisabled = false;
            this.init();
          }

          detectMobile() {
            // Check for mobile user agents
            const userAgent = navigator.userAgent || navigator.vendor || window.opera;
            
            // Mobile device patterns
            const mobilePatterns = [
              /Android/i,
              /webOS/i,
              /iPhone/i,
              /iPad/i,
              /iPod/i,
              /BlackBerry/i,
              /Windows Phone/i,
              /Opera Mini/i,
              /IEMobile/i,
              /Mobile/i
            ];

            // Check screen size (additional check for small screens)
            const isSmallScreen = window.innerWidth <= 768 || window.innerHeight <= 600;
            
            // Check touch capability
            const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
            
            // Return true if any mobile pattern matches OR if it's a small touch screen
            return mobilePatterns.some(pattern => pattern.test(userAgent)) || 
                   (isSmallScreen && isTouchDevice);
          }

          init() {
            if (this.isMobile && !this.overlayShown) {
              // Wait for DOM to be ready
              if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', () => this.showOverlay());
              } else {
                this.showOverlay();
              }
            }
          }

          showOverlay() {
            if (this.overlayShown) return;
            
            this.overlayShown = true;

            // Create overlay HTML
            const overlay = document.createElement('div');
            overlay.id = 'mobile-warning-overlay';
            overlay.innerHTML = `
              <div class="mobile-overlay-backdrop">
                <div class="mobile-overlay-content">
                  <div class="mobile-overlay-icon">
                    <svg width="48" height="48" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                      <path d="M12 2L2 7V10C2 16 6 20.5 12 22C18 20.5 22 16 22 10V7L12 2Z" stroke="#f59e0b" stroke-width="2" fill="#fef3c7"/>
                      <path d="M12 8V13M12 16H12.01" stroke="#f59e0b" stroke-width="2" stroke-linecap="round"/>
                    </svg>
                  </div>
                  <h2 class="mobile-overlay-title">Desktop Experience Recommended</h2>
                  <p class="mobile-overlay-description">
                    This metal-semiconductor junction experiment is optimized for desktop computers with larger screens and mouse interaction. 
                    While you can continue on mobile, you may experience:
                  </p>
                  <ul class="mobile-overlay-list">
                    <li>• Difficulty interacting with energy band diagrams</li>
                    <li>• Limited screen space for physics visualizations</li>
                    <li>• Reduced functionality for parameter controls</li>
                    <li>• Guided walkthrough will be disabled</li>
                  </ul>
                  <div class="mobile-overlay-actions">
                    <button class="mobile-overlay-btn mobile-overlay-btn-primary" onclick="mobileDetection.continueAnyway()">
                      Continue Anyway
                    </button>
                    <button class="mobile-overlay-btn mobile-overlay-btn-secondary" onclick="mobileDetection.goBack()">
                      Use Desktop Instead
                    </button>
                  </div>
                  <p class="mobile-overlay-footer">
                    For the best learning experience, please access this on a desktop or laptop computer.
                  </p>
                </div>
              </div>
            `;

            // Add overlay styles
            const styles = `
              <style>
                .mobile-overlay-backdrop {
                  position: fixed;
                  top: 0;
                  left: 0;
                  right: 0;
                  bottom: 0;
                  background: rgba(0, 0, 0, 0.8);
                  backdrop-filter: blur(4px);
                  z-index: 10000;
                  display: flex;
                  align-items: center;
                  justify-content: center;
                  padding: 20px;
                  animation: fadeIn 0.3s ease-out;
                }

                .mobile-overlay-content {
                  background: white;
                  border-radius: 16px;
                  padding: 24px;
                  max-width: 400px;
                  width: 100%;
                  max-height: 90vh;
                  overflow-y: auto;
                  text-align: center;
                  box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
                  animation: slideUp 0.3s ease-out;
                }

                .mobile-overlay-icon {
                  margin: 0 auto 16px;
                  width: 48px;
                  height: 48px;
                }

                .mobile-overlay-title {
                  font-size: 20px;
                  font-weight: 600;
                  color: #1f2937;
                  margin-bottom: 12px;
                  line-height: 1.3;
                }

                .mobile-overlay-description {
                  font-size: 14px;
                  color: #6b7280;
                  margin-bottom: 16px;
                  line-height: 1.5;
                  text-align: left;
                }

                .mobile-overlay-list {
                  text-align: left;
                  font-size: 14px;
                  color: #6b7280;
                  margin-bottom: 20px;
                  padding-left: 0;
                  list-style: none;
                }

                .mobile-overlay-list li {
                  margin-bottom: 6px;
                  line-height: 1.4;
                }

                .mobile-overlay-actions {
                  display: flex;
                  flex-direction: column;
                  gap: 12px;
                  margin-bottom: 16px;
                }

                .mobile-overlay-btn {
                  padding: 12px 20px;
                  border-radius: 8px;
                  font-size: 14px;
                  font-weight: 500;
                  border: none;
                  cursor: pointer;
                  transition: all 0.2s ease;
                  width: 100%;
                }

                .mobile-overlay-btn-primary {
                  background: #3b82f6;
                  color: white;
                }

                .mobile-overlay-btn-primary:hover {
                  background: #2563eb;
                  transform: translateY(-1px);
                }

                .mobile-overlay-btn-secondary {
                  background: #f3f4f6;
                  color: #374151;
                  border: 1px solid #d1d5db;
                }

                .mobile-overlay-btn-secondary:hover {
                  background: #e5e7eb;
                  transform: translateY(-1px);
                }

                .mobile-overlay-footer {
                  font-size: 12px;
                  color: #9ca3af;
                  line-height: 1.4;
                }

                @keyframes fadeIn {
                  from { opacity: 0; }
                  to { opacity: 1; }
                }

                @keyframes slideUp {
                  from { 
                    opacity: 0;
                    transform: translateY(20px) scale(0.95);
                  }
                  to { 
                    opacity: 1;
                    transform: translateY(0) scale(1);
                  }
                }

                @keyframes fadeOut {
                  from { opacity: 1; }
                  to { opacity: 0; }
                }

                /* Tour button disabled state for mobile */
                .floating-button.tour.mobile-disabled {
                  background: #9ca3af !important;
                  cursor: not-allowed !important;
                  opacity: 0.6 !important;
                }

                .floating-button.tour.mobile-disabled:hover {
                  transform: none !important;
                  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1) !important;
                }

                @media (min-width: 480px) {
                  .mobile-overlay-actions {
                    flex-direction: row;
                  }
                  
                  .mobile-overlay-btn {
                    width: auto;
                    flex: 1;
                  }
                }
              </style>
            `;

            // Add styles to head
            document.head.insertAdjacentHTML('beforeend', styles);
            
            // Add overlay to body
            document.body.appendChild(overlay);
            
            // Prevent body scrolling
            document.body.style.overflow = 'hidden';
          }

          continueAnyway() {
            this.walkthroughDisabled = true;
            this.hideOverlay();
            // Hide the tour button since walkthrough is disabled
            this.hideTourButton();
          }

          goBack() {
            // Try to go back in history, or redirect to a homepage if available
            if (window.history.length > 1) {
              window.history.back();
            } else {
              // You can customize this to redirect to your main page
              alert('Please bookmark this page and open it on a desktop computer for the best experience.');
            }
          }

          hideOverlay() {
            const overlay = document.getElementById('mobile-warning-overlay');
            if (overlay) {
              overlay.style.animation = 'fadeOut 0.3s ease-out forwards';
              setTimeout(() => {
                overlay.remove();
                document.body.style.overflow = '';
              }, 300);
            }
          }

          hideTourButton() {
            // Wait a bit to ensure the DOM is ready
            setTimeout(() => {
              const tourButton = document.querySelector('.floating-button.tour');
              if (tourButton) {
                // Instead of hiding, disable and add visual indication
                tourButton.classList.add('mobile-disabled');
                tourButton.setAttribute('title', 'Walkthrough disabled on mobile devices - Use desktop for full experience');
                // Also change the onclick to show the disabled message
                tourButton.setAttribute('onclick', 'startGuidedTour()'); // Keep the same function, it will handle the disabled state
              }
            }, 100);
          }

          // Method to check if walkthrough should be disabled
          isWalkthroughDisabled() {
            return this.isMobile && this.walkthroughDisabled;
          }
        }

        // Initialize mobile detection
        const mobileDetection = new MobileDetection();
    </script>

    <!-- Animated background particles -->
    <div class="bg-particles" id="particles"></div>

    <div class="container">
        <!-- Navigation -->
        <div class="nav-tabs">
            <div class="nav-tab active" data-tab="equilibrium">
                <i class="fas fa-balance-scale"></i>
                <span>Equilibrium</span>
            </div>
            <div class="nav-tab" data-tab="biasing">
                <i class="fas fa-bolt"></i>
                <span>Forward/Reverse Bias</span>
            </div>
            <div class="nav-tab" data-tab="applications">
                <i class="fas fa-cogs"></i>
                <span>Applications</span>
            </div>
            <div class="nav-tab" data-tab="challenges">
                <i class="fas fa-trophy"></i>
                <span>Challenges</span>
            </div>
        </div>

        <!-- Equilibrium Tab -->
        <div id="equilibrium" class="tab-content active">
            <div class="content-area">
                <div class="simulation-panel">
                    <h2 class="panel-title">
                        <i class="fas fa-eye"></i>
                        Junction Formation & Energy Bands
                    </h2>
                    <div class="visualization-canvas" id="equilibriumCanvas">
                        <!-- Visualization will be rendered here -->
                    </div>
                </div>

                <div class="controls-panel">
                    <h3 class="panel-title">
                        <i class="fas fa-sliders-h"></i>
                        Material Properties
                    </h3>

                    <div class="control-group">
                        <label class="control-label">Metal Work Function (eV)</label>
                        <input type="range" class="slider" id="workFunction" min="3.5" max="6.0" step="0.1" value="4.5">
                        <div class="control-value" id="workFunctionValue">4.5 eV</div>
                    </div>

                    <div class="control-group">
                        <label class="control-label">Semiconductor Type</label>
                        <select class="custom-select" id="semiconductorType">
                            <option value="n-type">N-type Silicon</option>
                            <option value="p-type">P-type Silicon</option>
                        </select>
                    </div>

                    <div class="control-group">
                        <label class="control-label">Doping Concentration (log₁₀ cm⁻³)</label>
                        <input type="range" class="slider" id="dopingConc" min="14" max="19" step="0.5" value="16">
                        <div class="control-value" id="dopingValue">10¹⁶ cm⁻³</div>
                    </div>

                    <div class="control-group">
                        <label class="control-label">Temperature (K)</label>
                        <input type="range" class="slider" id="temperature" min="200" max="400" step="10" value="300">
                        <div class="control-value" id="tempValue">300 K</div>
                    </div>

                    <button class="btn btn-primary" onclick="animateFormation()">
                        <i class="fas fa-play"></i>
                        Animate Formation
                    </button>

                    <div class="measurements">
                        <h4>Calculated Parameters</h4>
                        <div class="measurement-item">
                            <span class="measurement-label">Schottky Barrier Height:</span>
                            <span class="measurement-value" id="barrierHeight">0.65 eV</span>
                        </div>
                        <div class="measurement-item">
                            <span class="measurement-label">Built-in Potential:</span>
                            <span class="measurement-value" id="builtInPotential">0.45 V</span>
                        </div>
                        <div class="measurement-item">
                            <span class="measurement-label">Depletion Width:</span>
                            <span class="measurement-value" id="depletionWidth">0.12 μm</span>
                        </div>
                        <div class="measurement-item">
                            <span class="measurement-label">Max Electric Field:</span>
                            <span class="measurement-value" id="maxElectricField">7.5×10⁴ V/cm</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Biasing Tab -->
        <div id="biasing" class="tab-content">
            <div class="content-area">
                <div class="simulation-panel">
                    <h2 class="panel-title">
                        <i class="fas fa-battery-three-quarters"></i>
                        Biased Junction Behavior
                    </h2>
                    <div class="visualization-canvas" id="biasingCanvas">
                        <!-- Biasing visualization -->
                    </div>
                </div>

                <div class="controls-panel">
                    <h3 class="panel-title">
                        <i class="fas fa-bolt"></i>
                        Bias Controls
                    </h3>

                    <div class="control-group">
                        <label class="control-label">Applied Voltage (V)</label>
                        <input type="range" class="slider" id="biasVoltage" min="-2" max="2" step="0.1" value="0">
                        <div class="control-value" id="biasValue">0.0 V</div>
                    </div>

                    <div class="control-group">
                        <label class="control-label">Bias Condition</label>
                        <div class="control-value" id="biasCondition">Equilibrium</div>
                    </div>

                    <button class="btn btn-primary" onclick="sweepVoltage()">
                        <i class="fas fa-chart-line"></i>
                        Voltage Sweep
                    </button>

                    <button class="btn btn-secondary" onclick="stopSweep()">
                        <i class="fas fa-stop"></i>
                        Stop Sweep
                    </button>

                    <div class="measurements">
                        <h4>Biased Parameters</h4>
                        <div class="measurement-item">
                            <span class="measurement-label">Current Density:</span>
                            <span class="measurement-value" id="currentDensity">0 A/cm²</span>
                        </div>
                        <div class="measurement-item">
                            <span class="measurement-label">Effective Barrier:</span>
                            <span class="measurement-value" id="effectiveBarrier">0.65 eV</span>
                        </div>
                        <div class="measurement-item">
                            <span class="measurement-label">Depletion Change:</span>
                            <span class="measurement-value" id="depletionChange">0%</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Applications Tab -->
        <div id="applications" class="tab-content">
            <div class="content-area">
                <div class="simulation-panel">
                    <h2 class="panel-title">
                        <i class="fas fa-microchip"></i>
                        Schottky Device Applications
                    </h2>
                    <div class="visualization-canvas" id="applicationsCanvas">
                        <!-- Applications demonstration -->
                    </div>
                    
                    <!-- Performance Measurements moved below simulation -->
                    <div class="measurements" style="margin-top: 20px;">
                        <h4>Performance Metrics</h4>
                        <div class="measurement-item">
                            <span class="measurement-label">DC Output Voltage:</span>
                            <span class="measurement-value" id="dcVoltage">3.7 V</span>
                        </div>
                        <div class="measurement-item">
                            <span class="measurement-label">Ripple Factor:</span>
                            <span class="measurement-value" id="rippleFactor">121%</span>
                        </div>
                        <div class="measurement-item">
                            <span class="measurement-label">Efficiency:</span>
                            <span class="measurement-value" id="efficiency">40.6%</span>
                        </div>
                    </div>
                </div>

                <div class="controls-panel">
                    <h3 class="panel-title">
                        <i class="fas fa-cogs"></i>
                        Application Type
                    </h3>

                    <div class="control-group">
                        <label class="control-label">Device Application</label>
                        <select class="custom-select" id="applicationType">
                            <option value="rectifier">Rectifier Circuit</option>
                        </select>
                    </div>

                    <!-- Rectifier Controls -->
                    <div id="rectifierControls" class="rectifier-controls">
                        <div class="control-group">
                            <label class="control-label">Rectifier Type</label>
                            <select class="custom-select" id="rectifierType">
                                <option value="half-wave">Half-Wave Rectifier</option>
                                <option value="full-wave">Full-Wave Bridge Rectifier</option>
                            </select>
                        </div>

                        <div class="control-group">
                            <label class="control-label">Input Signal Frequency (Hz)</label>
                            <input type="range" class="slider" id="signalFreq" min="50" max="1000" step="50" value="60">
                            <div class="control-value" id="freqValue">60 Hz</div>
                        </div>

                        <div class="control-group">
                            <label class="control-label">Load Resistance (Ω)</label>
                            <input type="range" class="slider" id="loadResistance" min="10" max="1000" step="10" value="100">
                            <div class="control-value" id="loadValue">100 Ω</div>
                        </div>

                        <div class="control-group">
                            <label class="control-label">
                                <input type="checkbox" id="addCapacitor" style="margin-right: 8px;">
                                Add Filter Capacitor
                            </label>
                            <div style="margin-top: 10px;">
                                <label class="control-label" style="font-size: 0.9em;">Capacitance (μF)</label>
                                <input type="range" class="slider" id="capacitance" min="10" max="1000" step="50" value="470" disabled>
                                <div class="control-value" id="capacitanceValue">470 μF</div>
                            </div>
                        </div>

                        <button class="btn btn-secondary" onclick="resetDemo()">
                            <i class="fas fa-refresh"></i>
                            Reset Simulation
                        </button>
                        
                        <div style="margin-top: 15px; padding: 10px; background: rgba(16, 185, 129, 0.1); border: 1px solid rgba(16, 185, 129, 0.3); border-radius: 8px; text-align: center;">
                            <div style="color: #10b981; font-weight: 600; margin-bottom: 5px;">
                                <i class="fas fa-cog fa-spin"></i> Simulation Running
                            </div>
                            <div style="font-size: 0.9em; color: #6b7280;">
                                Adjust controls above to see real-time changes
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Challenges Tab -->
        <div id="challenges" class="tab-content">
            <div class="challenge-container">
                <!-- Challenge Progress -->
                <div class="challenge-progress">
                    <div class="challenge-progress-bar" id="overallProgress"></div>
                </div>

                <!-- Challenge Stats -->
                <div class="challenge-stats">
                    <div class="stat-item">
                        <div class="stat-value" id="totalScore">0</div>
                        <div class="stat-label">Total Score</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="challengesSolved">0</div>
                        <div class="stat-label">Challenges Solved</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="hintsUsed">0</div>
                        <div class="stat-label">Hints Used</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="accuracy">100%</div>
                        <div class="stat-label">Accuracy</div>
                    </div>
                </div>

                <!-- Challenge 1: Rapid Fire Quiz -->
                <div class="challenge-section" id="challenge1">
                    <div class="challenge-header">
                        <div class="challenge-icon">
                            <i class="fas fa-bolt"></i>
                        </div>
                        <div>
                            <h3 class="challenge-title">Rapid Fire Quiz</h3>
                            <p class="challenge-description">Test your knowledge with quick questions about Schottky junctions</p>
                        </div>
                    </div>
                    <div id="rapidFireContent">
                        <!-- Questions will be generated here -->
                    </div>
                    <div class="challenge-controls">
                        <button class="challenge-btn challenge-btn-primary" onclick="checkQuizAnswers(1)">Submit Answers</button>
                        <button class="challenge-btn challenge-btn-secondary" onclick="showQuizHints(1)">Show Hints</button>
                        <button class="challenge-btn challenge-btn-secondary" onclick="resetChallenge(1)">Reset</button>
                    </div>
                    <div class="challenge-feedback" id="challenge1Feedback"></div>
                    <div class="challenge-hint" id="challenge1Hint"></div>
                </div>

                <!-- Challenge 2: Advanced Concepts -->
                <div class="challenge-section" id="challenge2">
                    <div class="challenge-header">
                        <div class="challenge-icon">
                            <i class="fas fa-brain"></i>
                        </div>
                        <div>
                            <h3 class="challenge-title">Advanced Concepts</h3>
                            <p class="challenge-description">Explore deeper concepts of metal-semiconductor junctions</p>
                        </div>
                    </div>
                    <div id="advancedContent">
                        <!-- Advanced questions will be generated here -->
                    </div>
                    <div class="challenge-controls">
                        <button class="challenge-btn challenge-btn-primary" onclick="checkAdvancedAnswers()">Submit Answers</button>
                        <button class="challenge-btn challenge-btn-secondary" onclick="showAdvancedHints()">Show Hints</button>
                        <button class="challenge-btn challenge-btn-secondary" onclick="resetChallenge(2)">Reset</button>
                    </div>
                    <div class="challenge-feedback" id="challenge2Feedback"></div>
                    <div class="challenge-hint" id="challenge2Hint"></div>
                </div>

                <!-- Challenge 3: Fill in the Blanks -->
                <div class="challenge-section" id="challenge3">
                    <div class="challenge-header">
                        <div class="challenge-icon">
                            <i class="fas fa-edit"></i>
                        </div>
                        <div>
                            <h3 class="challenge-title">Fill in the Blanks</h3>
                            <p class="challenge-description">Complete the statements about Schottky junctions</p>
                        </div>
                    </div>
                    <div id="fillBlanksContent">
                        <!-- Fill in the blanks will be generated here -->
                    </div>
                    <div class="challenge-controls">
                        <button class="challenge-btn challenge-btn-primary" onclick="checkFillBlanks()">Check Answers</button>
                        <button class="challenge-btn challenge-btn-secondary" onclick="showFillBlanksHint()">Show Hints</button>
                        <button class="challenge-btn challenge-btn-secondary" onclick="resetChallenge(3)">Reset</button>
                    </div>
                    <div class="challenge-feedback" id="challenge3Feedback"></div>
                    <div class="challenge-hint" id="challenge3Hint"></div>
                </div>

                <!-- Challenge 4: Calculations -->
                <div class="challenge-section" id="challenge4">
                    <div class="challenge-header">
                        <div class="challenge-icon">
                            <i class="fas fa-calculator"></i>
                        </div>
                        <div>
                            <h3 class="challenge-title">Calculation Challenge</h3>
                            <p class="challenge-description">Solve numerical problems related to Schottky junctions</p>
                        </div>
                    </div>
                    <div id="calculationContent">
                        <!-- Calculation problems will be generated here -->
                    </div>
                    <div class="challenge-controls">
                        <button class="challenge-btn challenge-btn-primary" onclick="checkCalculations()">Check Calculations</button>
                        <button class="challenge-btn challenge-btn-secondary" onclick="showCalculationHint()">Show Hints</button>
                        <button class="challenge-btn challenge-btn-secondary" onclick="resetChallenge(4)">Reset</button>
                    </div>
                    <div class="challenge-feedback" id="challenge4Feedback"></div>
                    <div class="challenge-hint" id="challenge4Hint"></div>
                </div>

                <!-- Challenge 5: Matching -->
                <div class="challenge-section" id="challenge5">
                    <div class="challenge-header">
                        <div class="challenge-icon">
                            <i class="fas fa-link"></i>
                        </div>
                        <div>
                            <h3 class="challenge-title">Concept Matching</h3>
                            <p class="challenge-description">Match terms with their definitions</p>
                        </div>
                    </div>
                    <div id="matchingContent">
                        <!-- Matching exercise will be generated here -->
                    </div>
                    <div class="challenge-controls">
                        <button class="challenge-btn challenge-btn-primary" onclick="checkMatching()">Check Matches</button>
                        <button class="challenge-btn challenge-btn-secondary" onclick="showMatchingHints()">Show Hints</button>
                        <button class="challenge-btn challenge-btn-secondary" onclick="showMatchingAnswerKey()">Show Answer Key</button>
                        <button class="challenge-btn challenge-btn-secondary" onclick="resetChallenge(5)">Reset</button>
                    </div>
                    <div class="challenge-feedback" id="challenge5Feedback"></div>
                    <div class="challenge-hint" id="challenge5Hint"></div>
                </div>

                <!-- Overall Challenge Controls -->
                <div class="challenge-controls" style="margin-top: 30px; padding-top: 20px; border-top: 2px solid #e5e7eb;">
                    <button class="challenge-btn challenge-btn-primary" onclick="generateNewQuestions()">
                        <i class="fas fa-dice"></i>
                        Generate New Questions
                    </button>
                    <button class="challenge-btn challenge-btn-secondary" onclick="resetAllChallenges()">Reset All Challenges</button>
                    <button class="challenge-btn challenge-btn-secondary" onclick="showCompletionModal()">View Progress</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Floating Tour Button -->
    <div class="floating-button tour" onclick="startGuidedTour()">
        <i class="fas fa-route"></i>
    </div>

    <!-- Tour Elements -->
    <div class="tour-overlay" id="tourOverlay">
        <div class="tour-spotlight" id="tourSpotlight"></div>
        <div class="tour-spotlight-secondary" id="tourSpotlightSecondary" style="display: none;"></div>
    </div>

    <div class="tour-popup" id="tourPopup">
        <div class="tour-header">
            <div class="tour-step-number" id="tourStepNumber">1/15</div>
            <h3 class="tour-title" id="tourTitle">Welcome!</h3>
        </div>
        <div class="tour-progress">
            <div class="tour-progress-bar" id="tourProgressBar" style="width: 0%"></div>
        </div>
        <div class="tour-content" id="tourContent">
            Let's explore the metal-semiconductor junction!
        </div>
        <div id="tourChallenge" class="tour-challenge" style="display: none;">
            <div class="tour-challenge-title">
                <i class="fas fa-tasks"></i>
                <span>Interactive Challenge</span>
            </div>
            <div class="tour-challenge-content" id="tourChallengeContent">
                Complete this task to continue!
            </div>
        </div>
        <div class="tour-controls">
            <button class="tour-btn tour-btn-secondary" id="tourPrevBtn" onclick="prevTourStep()">Previous</button>
            <button class="tour-btn tour-btn-secondary" onclick="showHint()" id="tourHintBtn" style="display: none;">Hint</button>
            <button class="tour-btn tour-btn-primary" id="tourNextBtn" onclick="nextTourStep()">Next</button>
            <button class="tour-btn tour-btn-skip" id="tourSkipBtn" onclick="skipTour()" title="Skip the entire tour">Skip Tour</button>
        </div>
    </div>

    <div class="tour-score" id="tourScore">
        <div class="tour-score-title">🏆 Your Progress</div>
        <div class="tour-score-item">
            <span>Score:</span>
            <span id="tourScoreValue">0</span>
        </div>
        <div class="tour-score-item">
            <span>Steps:</span>
            <span id="stepsCompleted">0/15</span>
        </div>
        <div class="tour-score-item">
            <span>Challenges:</span>
            <span id="challengesCompleted">0/8</span>
        </div>
    </div>

    <div class="tour-achievements" id="tourAchievements">
        <div class="achievement-icon">🎉</div>
        <div class="achievement-title" id="achievementTitle">Achievement Unlocked!</div>
        <div class="achievement-description" id="achievementDescription">You've mastered a new concept!</div>
        <button class="tour-btn tour-btn-primary" onclick="closeAchievement()">Continue</button>
    </div>

    <script>
        // Global variables
        let currentTab = 'equilibrium';
        let animationId = null;
        let isDemoRunning = false;
        let time = 0;
        let sweepRunning = false;

        // Tour tracking variables
        let tourActive = false;
        let currentTourStep = 0;
        let tourScore = 0;
        let challengesSolvedInTour = 0;
        let hintsUsedInTour = 0;

        // Challenge tracking variables
        let challengeAnswers = {
            rapidFire: [],
            advanced: [],
            fillBlanks: {},
            calculations: {},
            matching: {}
        };

        let challengeStates = {
            1: { completed: false, score: 0 },
            2: { completed: false, score: 0 },
            3: { completed: false, score: 0 },
            4: { completed: false, score: 0 },
            5: { completed: false, score: 0 }
        };

        let totalScore = 0;
        let challengesSolved = 0;
        let hintsUsed = 0;
        let selectedQuestions = {};
        let selectedMatchingItems = [];
        let connectionLines = {};
        let currentConnectionId = 0;
        let usedQuestionIndices = {
            rapidFire: [],
            advanced: [],
            fillBlanks: [],
            calculations: [],
            matching: []
        };

        // Physics constants
        const CONSTANTS = {
            k: 8.617e-5, // Boltzmann constant in eV/K
            q: 1.602e-19, // Elementary charge in C
            eps_si: 11.9, // Silicon relative permittivity
            eps_0: 8.854e-14, // Free space permittivity in F/cm
            Si_EA: 4.05, // Silicon electron affinity in eV
            Si_Eg: 1.12, // Silicon bandgap in eV
            A_star: 112, // Richardson constant for silicon in A/cm²K²
            Nc: 2.8e19, // Effective density of states in conduction band
            Nv: 1.04e19 // Effective density of states in valence band
        };

        // Enhanced question bank with detailed explanations and hints
        const questionBank = {
            rapidFire: [
                {
                    question: "What is the primary difference between a Schottky junction and a PN junction?",
                    options: ["Material composition", "Charge carrier type", "Junction type", "Temperature dependence"],
                    correct: 0,
                    explanation: "A Schottky junction is formed between a metal and semiconductor, while a PN junction is formed between P-type and N-type semiconductors.",
                    hint: "Think about what materials form each type of junction."
                },
                {
                    question: "In a Schottky diode, the barrier height primarily depends on:",
                    options: ["Temperature only", "Metal work function and semiconductor properties", "Applied voltage only", "Doping concentration only"],
                    correct: 1,
                    explanation: "The Schottky barrier height is determined by the difference between the metal work function and the semiconductor electron affinity or ionization energy.",
                    hint: "Consider the energy levels of the metal and semiconductor when they come into contact."
                },
                {
                    question: "What happens to the depletion region width when forward bias is applied?",
                    options: ["Increases", "Decreases", "Remains constant", "Becomes zero"],
                    correct: 1,
                    explanation: "Forward bias reduces the potential barrier, causing the depletion region to narrow.",
                    hint: "Think about how bias affects the electric field in the junction."
                },
                {
                    question: "Schottky diodes are preferred for high-frequency applications because:",
                    options: ["High forward voltage", "Low capacitance and fast switching", "High power handling", "Low cost"],
                    correct: 1,
                    explanation: "Schottky diodes have lower junction capacitance and faster switching speeds due to majority carrier conduction.",
                    hint: "Consider the charge storage and switching characteristics."
                },
                {
                    question: "The current in a Schottky diode is primarily due to:",
                    options: ["Minority carriers", "Majority carriers", "Both equally", "Photogenerated carriers"],
                    correct: 1,
                    explanation: "Schottky diodes operate based on majority carrier injection over the potential barrier.",
                    hint: "Think about the conduction mechanism in metal-semiconductor junctions."
                },
                {
                    question: "What is the typical forward voltage drop of a Schottky diode?",
                    options: ["0.7V", "0.3V", "1.2V", "2.0V"],
                    correct: 1,
                    explanation: "Schottky diodes typically have lower forward voltage drops (0.2-0.5V) compared to PN diodes (0.7V).",
                    hint: "Compare with the forward voltage of regular silicon diodes."
                }
            ],
            advanced: [
                {
                    question: "The Richardson-Dushman equation describes:",
                    options: ["Drift current", "Diffusion current", "Thermionic emission current", "Tunnel current"],
                    correct: 2,
                    explanation: "The Richardson-Dushman equation describes the thermionic emission of electrons over the Schottky barrier.",
                    hint: "This equation is fundamental to understanding current flow in Schottky junctions."
                },
                {
                    question: "Image force lowering in Schottky junctions:",
                    options: ["Increases barrier height", "Decreases barrier height", "Has no effect", "Only affects capacitance"],
                    correct: 1,
                    explanation: "Image force lowering reduces the effective barrier height due to the attractive force between the electron and its image charge in the metal.",
                    hint: "Consider the electrostatic interaction between charge and conductor."
                },
                {
                    question: "In which application are Schottky diodes NOT typically used?",
                    options: ["Power rectifiers", "High-voltage applications", "RF detectors", "Switch-mode power supplies"],
                    correct: 1,
                    explanation: "Schottky diodes have lower breakdown voltages and are not suitable for high-voltage applications.",
                    hint: "Think about the limitations of Schottky diodes compared to PN diodes."
                },
                {
                    question: "The ideality factor in a Schottky diode is typically:",
                    options: ["Less than 1", "Equal to 1", "Greater than 1", "Always 2"],
                    correct: 2,
                    explanation: "The ideality factor is typically greater than 1 due to non-ideal effects like image force lowering and interface states.",
                    hint: "Real diodes deviate from ideal behavior due to various physical effects."
                }
            ],
            fillBlanks: [
                {
                    text: "The Schottky barrier height for an n-type semiconductor is given by the difference between the metal work function and the semiconductor _____ affinity.",
                    blanks: ["electron"],
                    explanation: "The electron affinity represents how easily electrons can be removed from the semiconductor.",
                    hint: "This parameter is related to the energy required to remove electrons from the semiconductor surface."
                },
                {
                    text: "In thermionic emission theory, the current density increases exponentially with _____ due to more carriers having sufficient energy to overcome the barrier.",
                    blanks: ["temperature"],
                    explanation: "Higher temperature provides more thermal energy to carriers, enabling them to overcome the Schottky barrier.",
                    hint: "Think about how thermal energy affects the ability of carriers to cross energy barriers."
                },
                {
                    text: "Schottky diodes are preferred for high-frequency applications because they operate with _____ carriers, eliminating minority carrier storage effects.",
                    blanks: ["majority"],
                    explanation: "Majority carrier operation eliminates the charge storage delay associated with minority carriers in PN junctions.",
                    hint: "Consider the difference between majority and minority carrier-based devices in terms of switching speed."
                },
                {
                    text: "The depletion region in a Schottky junction exists primarily in the _____ because metals have much higher carrier concentrations than semiconductors.",
                    blanks: ["semiconductor"],
                    explanation: "Due to the large difference in carrier concentrations, the depletion region extends mainly into the semiconductor.",
                    hint: "Think about where charges are depleted when materials with very different carrier densities are joined."
                },
                {
                    text: "Forward bias _____ the effective barrier height, allowing more carriers to cross the junction and increasing current flow.",
                    blanks: ["reduces"],
                    explanation: "Forward bias lowers the potential barrier, making it easier for carriers to cross the junction.",
                    hint: "Consider how applied voltage affects the energy barrier that carriers must overcome."
                }
            ],
            calculations: [
                {
                    question: "Calculate the Schottky barrier height for aluminum (φM = 4.1 eV) on n-type silicon (χ = 4.05 eV):",
                    answer: "0.05",
                    unit: "eV",
                    tolerance: 0.01,
                    explanation: "φB = φM - χ = 4.1 - 4.05 = 0.05 eV",
                    hint: "Use the formula φB = φM - χ for n-type semiconductors."
                },
                {
                    question: "If the doping concentration is 10¹⁶ cm⁻³ and the built-in potential is 0.5V, calculate the depletion width in micrometers (εr = 11.9):",
                    answer: "0.83",
                    unit: "μm",
                    tolerance: 0.1,
                    explanation: "Using W = √(2εrε₀Vbi/qNd) with the given values.",
                    hint: "Use the depletion width formula for Schottky junctions."
                }
            ],
            matching: [
                {
                    terms: ["Schottky Barrier", "Image Force", "Thermionic Emission", "Ideality Factor"],
                    definitions: [
                        "Energy barrier at metal-semiconductor interface",
                        "Electrostatic attraction lowering barrier height", 
                        "Emission of electrons over potential barrier",
                        "Parameter describing deviation from ideal diode behavior"
                    ]
                }
            ]
        };

        // Comprehensive Metal-Semiconductor Junction Tour Steps
        const tourSteps = [
            {
                title: "Welcome to Metal-Semiconductor Junctions! 🔬",
                content: "Discover the fascinating world of Schottky barriers and metal-semiconductor interfaces! This simulation covers energy band diagrams, barrier heights, and device physics. Let's explore how metals and semiconductors interact to create essential electronic devices.",
                target: ".container",
                challenge: null,
                position: "center"
            },
            {
                title: "Navigation Overview 🧭",
                content: "Your simulation has four main sections: Equilibrium (energy bands), Biasing (current-voltage), Applications (real devices), and Challenges (test your knowledge). Each tab reveals different aspects of metal-semiconductor physics.",
                target: ".nav-tabs",
                challenge: null,
                position: "bottom"
            },
            {
                title: "Understanding Energy Band Diagrams 📊",
                content: "This energy band diagram is fundamental to understanding metal-semiconductor junctions! The diagram shows:\n\n🔸 **Metal (left)**: Has a continuous density of states filled up to the Fermi level (red dashed line)\n🔸 **Semiconductor (right)**: Shows distinct energy bands:\n   • Conduction Band (upper): Where electrons can move freely\n   • Valence Band (lower): Where electrons are bound to atoms\n   • Band Gap: Forbidden energy region between bands\n\n🎯 **Key Physics**: When metal and semiconductor contact, their Fermi levels align, creating band bending and the Schottky barrier. This barrier controls electron flow across the interface!",
                target: "#equilibriumCanvas",
                challenge: null,
                position: "right"
            },
            {
                title: "Band Bending & Barrier Formation 🌊",
                content: "**Why do energy bands bend?** When metal and semiconductor contact:\n\n📐 **Before Contact**: Each material has its own Fermi level\n📐 **After Contact**: Fermi levels must align (thermal equilibrium)\n📐 **Result**: Electron transfer creates electric field\n\n🔬 **Physics Details**:\n• Electrons flow from high to low Fermi level\n• Charge transfer creates depletion region\n• Electric field bends semiconductor bands\n• Barrier height = |φₘ - χₛ| (work function difference)\n\n⚡ **The Schottky Barrier**: This potential barrier controls current flow - electrons must have enough energy to overcome it!",
                target: "#equilibriumCanvas", 
                challenge: null,
                position: "left"
            },
            {
                title: "🎯 Challenge 1: Metal Work Function Explorer",
                content: "The Schottky barrier height depends critically on the metal work function! Let's discover how different work functions create different barrier heights.",
                target: "#workFunction",
                challenge: {
                    type: "range_target",
                    instruction: "📝 Increase the work function to 5.5eV and observe how the barrier height changes!\n\n🔍 Look for the 'Schottky Barrier Height' measurement - it should increase significantly!",
                    target_element: "#workFunction",
                    target_value: 5.5,
                    tolerance: 0.1,
                    hint: "🎯 The Work Function slider is highlighted. Higher work function metals create larger Schottky barriers. Move the slider to 5.5eV and watch the barrier height increase!",
                    reward: 150,
                    secondary_highlight: "#barrierHeight"
                },
                position: "top"
            },
            {
                title: "Excellent Discovery! ⚡",
                content: "Outstanding! You've discovered that higher work function metals create larger Schottky barriers. This is fundamental physics - the barrier height equals the difference between the metal work function and semiconductor electron affinity. This principle is crucial for device design!",
                target: "#barrierHeight",
                challenge: null,
                position: "center"
            },
            {
                title: "🎯 Challenge 2: Semiconductor Type Investigation",
                content: "The junction behavior depends on whether we use n-type or p-type semiconductors. Let's explore this fundamental difference!",
                target: "#semiconductorType",
                challenge: {
                    type: "semiconductor_type",
                    instruction: "📝 Switch from n-type to p-type semiconductor and observe the dramatic change in energy bands!\n\n🔍 Watch how the band bending direction reverses!",
                    target_element: "#semiconductorType",
                    target_value: "p-type",
                    hint: "🎯 Change the 'Semiconductor Type' to p-type. In p-type junctions, the bands bend upward instead of downward, creating different electrical characteristics!",
                    reward: 130,
                    secondary_highlight: "#equilibriumCanvas"
                },
                position: "top"
            },
            {
                title: "🎯 Challenge 3: Doping Concentration Effects",
                content: "Doping concentration dramatically affects the depletion width and barrier shape. Higher doping creates sharper barriers!",
                target: "#dopingConc",
                challenge: {
                    type: "range_target",
                    instruction: "📝 Increase the doping concentration to 10¹⁸ cm⁻³ and observe how the depletion width shrinks!\n\n🔍 Higher doping = thinner depletion region = steeper barrier!",
                    target_element: "#dopingConc",
                    target_value: 18,
                    tolerance: 0.5,
                    hint: "🎯 Move the doping slider to maximum (10¹⁸). Higher doping concentrations create thinner depletion regions, making the barrier steeper and more abrupt.",
                    reward: 140,
                    secondary_highlight: "#depletionWidth"
                },
                position: "left"
            },
            {
                title: "🎯 Challenge 4: Temperature Effects on Barriers",
                content: "Temperature affects both the barrier height and the carrier concentration. Let's heat things up!",
                target: "#temperature",
                challenge: {
                    type: "temperature_experiment",
                    instruction: "📝 Increase temperature to 400K and observe how thermal energy affects the barrier!\n\n🔍 Higher temperature increases carrier energy and affects barrier effectiveness!",
                    target_element: "#temperature",
                    target_value: 400,
                    tolerance: 10,
                    hint: "🎯 Increase temperature to 400K. Higher temperatures provide more thermal energy to carriers, affecting their ability to overcome the Schottky barrier.",
                    reward: 120
                },
                position: "left"
            },
            {
                title: "Now Let's Apply Bias! ⚡",
                content: "**Understanding Bias Effects on Energy Bands**:\n\n🔄 **Forward Bias (V > 0)**:\n• External voltage reduces barrier height\n• Energy bands tilt downward\n• Electrons gain energy to overcome barrier\n• Exponential current increase!\n\n🔄 **Reverse Bias (V < 0)**:\n• External voltage increases barrier height\n• Energy bands tilt upward\n• Higher barrier blocks electron flow\n• Only tiny leakage current flows\n\n🎯 **Key Physics**: Bias voltage directly adds/subtracts from barrier height, dramatically affecting current flow through thermionic emission!",
                target: ".nav-tab[data-tab='biasing']",
                challenge: {
                    type: "tab_switch",
                    instruction: "📝 Click on the 'Forward/Reverse Bias' tab to explore dynamic junction behavior!",
                    target_element: ".nav-tab[data-tab='biasing']",
                    target_value: "biasing",
                    hint: "🎯 Click on the 'Forward/Reverse Bias' tab. This section shows how external voltage affects current flow through the metal-semiconductor junction.",
                    reward: 50
                },
                position: "bottom"
            },
            {
                title: "🎯 Challenge 5: Forward Bias Current Flow",
                content: "**Forward Bias & Thermionic Emission Physics**:\n\n⚡ **Current Equation**: J = A*T²·exp(-φB/kT)·[exp(qV/nkT) - 1]\n\n🔬 **Physical Process**:\n• Electrons in metal gain thermal energy\n• Forward bias reduces effective barrier height\n• More electrons have enough energy to overcome barrier\n• Result: Exponential current increase!\n\n🎯 **Key Insight**: Even small voltage changes create huge current changes due to exponential relationship!\n\n📊 **Schottky Advantage**: Lower barrier height means lower turn-on voltage (0.2-0.4V vs 0.7V for PN junctions)",
                target: "#biasVoltage",
                challenge: {
                    type: "forward_bias",
                    instruction: "📝 Apply +0.3V forward bias and observe the exponential current increase!\n\n🔍 Even small voltages create large current changes in Schottky diodes!",
                    target_element: "#biasVoltage",
                    target_value: 0.3,
                    tolerance: 0.05,
                    hint: "🎯 Set the voltage to +0.3V. Schottky diodes have lower turn-on voltages than PN junctions, typically 0.2-0.4V instead of 0.7V.",
                    reward: 180,
                    secondary_highlight: "#currentDensity"
                },
                position: "left"
            },
            {
                title: "🎯 Challenge 6: Reverse Bias Blocking",
                content: "In reverse bias, the barrier height increases, blocking current flow. This is how diodes provide rectification!",
                target: "#biasVoltage",
                challenge: {
                    type: "reverse_bias",
                    instruction: "📝 Apply -1V reverse bias and see how effectively the junction blocks current!\n\n🔍 Notice the very small reverse current - this is the rectifying action!",
                    target_element: "#biasVoltage",
                    target_value: -1.0,
                    tolerance: 0.1,
                    hint: "🎯 Set voltage to -1V. In reverse bias, only a tiny leakage current flows, demonstrating the diode's ability to block current in one direction.",
                    reward: 160
                },
                position: "left"
            },
            {
                title: "Real-World Applications! 🔧",
                content: "Schottky diodes are used in high-frequency circuits, power supplies, and solar cells. Let's explore practical applications!",
                target: ".nav-tab[data-tab='applications']",
                challenge: {
                    type: "tab_switch",
                    instruction: "📝 Click on the 'Applications' tab to see how these principles are used in real devices!",
                    target_element: ".nav-tab[data-tab='applications']",
                    target_value: "applications",
                    hint: "🎯 Click on the 'Applications' tab to explore practical uses of metal-semiconductor junctions in electronic devices.",
                    reward: 50
                },
                position: "bottom"
            },
            {
                title: "🎯 Challenge 7: High-Frequency Performance",
                content: "Schottky diodes excel at high frequencies due to majority carrier operation. Let's test their speed!",
                target: "#applicationType",
                challenge: {
                    type: "application_demo",
                    instruction: "📝 Select 'Rectifier Circuit' application and start the simulation to see real-world performance!\n\n🔍 Notice how efficiently the diode converts AC to DC!",
                    target_element: "#applicationType",
                    target_value: "rectifier",
                    hint: "🎯 The 'Device Application' should be set to 'Rectifier Circuit'. Then click 'Start Simulation' to see the Schottky diode in action!",
                    reward: 170
                },
                position: "top"
            },

            {
                title: "Full-Wave Bridge Rectification 🌉",
                content: "**Full-Wave Bridge Rectifier Superiority**:\n\n🔄 **Operation**: Uses 4 diodes to rectify both half-cycles\n📊 **Waveform**: Both positive AND negative half-cycles become positive\n⚡ **Efficiency**: ~81.2% (double that of half-wave!)\n📈 ** Higher efficiency (uses full AC cycle)\n• Better transformer utilization\n• Lower ripple content\n **Circuit**: 4 diodes in bridge configuration\n• D1,D3 conduct during positive half-cycle\n• D2,D4 conduct during negative half-cycle",
                target: "#rectifierType",
                challenge: {
                    type: "rectifier_comparison",
                    instruction: "📝 Now switch to 'Full-Wave Bridge' rectifier to compare performance!\n\n🔍 Notice the dramatic improvement in efficiency and reduction in ripple!",
                    target_element: "#rectifierType",
                    target_value: "full-wave",
                    hint: "🎯 Change the 'Rectifier Type' dropdown to 'Full-Wave Bridge' and observe how both half-cycles are utilized for better performance!",
                    reward: 180,
                    secondary_highlight: "#efficiency"
                },
                position: "left"
            },
            {
                title: "Half-Wave Rectification Basics 📡",
                content: "**Half-Wave Rectifier Fundamentals**:\n\n🔄 **Operation**: Diode conducts only during positive half-cycles\n📊 **Waveform**: Output = AC input with negative parts removed\n⚡ **Efficiency**: ~40.6% (theoretical maximum)\n📈 **Ripple**: High ripple factor (~121%)\n\n🎯 **Key Advantages**:\n• Simple circuit (one diode)\n• Low cost implementation\n\n❌ **Disadvantages**:\n• Poor efficiency\n• High ripple content\n• Wastes half the input power\n\n🔧 **Let's see it in action first, then explore improvements!**",
                target: "#rectifierType",
                challenge: {
                    type: "rectifier_demo",
                    instruction: "📝 Set the rectifier type to 'Half-Wave' to see basic rectification in action!\n\n🔍 Observe the waveform and note the efficiency and ripple values!",
                    target_element: "#rectifierType",
                    target_value: "half-wave",
                    hint: "🎯 Change the 'Rectifier Type' dropdown to 'Half-Wave' to see the simplest form of rectification.",
                    reward: 120,
                    secondary_highlight: "#efficiency"
                },
                position: "right"
            },
            {
                title: "Filter Capacitor Magic ⚡",
                content: "**Why Filter Capacitors Are Essential**:\n\n🔋 **Charging Phase**: Capacitor charges when diode conducts\n🔋 **Discharging Phase**: Capacitor supplies current when diode is off\n📊 **Result**: Much smoother DC output!\n\n🧮 **Key Equations**:\n• Ripple Factor = 1/(2√3·f·R·C) for half-wave\n• Ripple Factor = 1/(4√3·f·R·C) for full-wave\n• Where f=frequency, R=load resistance, C=capacitance\n\n🎯 **Trade-offs**:\n• Larger C → Lower ripple BUT slower response\n• Higher R → Lower ripple BUT higher voltage drop\n\n💡 **Design Tip**: Choose C such that time constant RC >> T (period)",
                target: "#addCapacitor",
                challenge: {
                    type: "capacitor_effect",
                    instruction: "📝 Toggle the filter capacitor ON and OFF to see the dramatic difference in output smoothness!\n\n🔍 Watch how the capacitor reduces ripple from ~121% to just a few percent!",
                    target_element: "#addCapacitor",
                    target_value: true,
                    hint: "🎯 Check the 'Add Filter Capacitor' checkbox to see how it smooths the rectified output by storing and releasing energy!",
                    reward: 160,
                    secondary_highlight: "#rippleFactor"
                },
                position: "bottom"
            },
            {
                title: "Why Schottky Diodes Excel in Rectifiers 🚀",
                content: "**Schottky vs PN Junction Diodes in Rectification**:\n\n⚡ **Lower Forward Voltage Drop**:\n• Schottky: 0.2-0.4V vs PN: 0.7V\n• Result: Higher efficiency, less power loss\n\n🏃 **Faster Switching Speed**:\n• No minority carrier storage\n• Majority carrier operation only\n• Perfect for high-frequency rectification\n\n🎯 **Applications Where Schottky Wins**:\n• Switch-mode power supplies (high frequency)\n• RF detectors and mixers\n• Solar cell bypass diodes\n• High-efficiency voltage regulators\n\n📊 **Trade-off**: Higher reverse leakage current than PN diodes",
                target: "#applicationType",
                challenge: null,
                position: "right"
            },
            {
                title: "🎯 Challenge 8: Test Your Mastery!",
                content: "Ready for the ultimate challenge? Test your understanding with comprehensive quizzes covering all aspects of metal-semiconductor physics!",
                target: ".nav-tab[data-tab='challenges']",
                challenge: {
                    type: "tab_switch",
                    instruction: "📝 Click on the 'Challenges' tab to test your mastery of metal-semiconductor junctions!",
                    target_element: ".nav-tab[data-tab='challenges']",
                    target_value: "challenges",
                    hint: "🎯 Click on the 'Challenges' tab to access comprehensive quizzes covering Schottky barrier physics, device applications, and advanced concepts.",
                    reward: 100
                },
                position: "bottom"
            },
            {
                title: "🏆 Congratulations, Schottky Expert!",
                content: "You've mastered metal-semiconductor junction physics! You understand energy band diagrams, Schottky barriers, bias effects, current mechanisms, and practical applications. You're now ready to design and analyze real Schottky diode circuits!",
                target: ".container",
                challenge: null,
                position: "center"
            }
        ];

        // Random question selection system
        function selectRandomQuestions() {
            selectedQuestions = {
                rapidFire: getRandomItems(questionBank.rapidFire, 3, 'rapidFire'),
                advanced: getRandomItems(questionBank.advanced, 2, 'advanced'),
                fillBlanks: getRandomItems(questionBank.fillBlanks, 2, 'fillBlanks'),
                calculations: getRandomItems(questionBank.calculations, 1, 'calculations'),
                matching: getRandomItems(questionBank.matching, 1, 'matching')
            };
            initializeChallengeAnswers();
        }

        function getRandomItems(array, count, questionType) {
            // Get available indices (not previously used)
            const availableIndices = [];
            for (let i = 0; i < array.length; i++) {
                if (!usedQuestionIndices[questionType].includes(i)) {
                    availableIndices.push(i);
                }
            }
            
            // If we've used all questions, reset the used indices for this type
            if (availableIndices.length < count) {
                usedQuestionIndices[questionType] = [];
                availableIndices.length = 0;
                for (let i = 0; i < array.length; i++) {
                    availableIndices.push(i);
                }
            }
            
            // Randomly select from available indices
            const selectedIndices = [];
            const shuffledAvailable = availableIndices.sort(() => 0.5 - Math.random());
            
            for (let i = 0; i < Math.min(count, shuffledAvailable.length); i++) {
                const selectedIndex = shuffledAvailable[i];
                selectedIndices.push(selectedIndex);
                usedQuestionIndices[questionType].push(selectedIndex);
            }
            
            // Return the selected questions
            return selectedIndices.map(index => array[index]);
        }

        function initializeChallengeAnswers() {
            challengeAnswers = {
                rapidFire: new Array(selectedQuestions.rapidFire.length).fill(null),
                advanced: new Array(selectedQuestions.advanced.length).fill(null),
                fillBlanks: {},
                calculations: {},
                matching: {}
            };
        }

        // Utility functions
        function safeGetElement(id) {
            const element = document.getElementById(id);
            return element;
        }

        function safeGetValue(id, defaultValue = 0) {
            const element = safeGetElement(id);
            return element ? parseFloat(element.value) || defaultValue : defaultValue;
        }

        function safeSetValue(id, value) {
            const element = safeGetElement(id);
            if (element) {
                element.textContent = value;
            }
        }

        // Challenge Functions
        function generateChallengeContent() {
            generateRapidFireQuiz();
            generateAdvancedConcepts();
            generateFillInTheBlanks();
            generateCalculationChallenge();
            generateMatching();
        }

        function generateRapidFireQuiz() {
            const container = document.getElementById('rapidFireContent');
            if (!container) return;
            
            let html = '';
            selectedQuestions.rapidFire.forEach((q, index) => {
                html += `
                    <div class="quiz-question">
                        <h4>Question ${index + 1}: ${q.question}</h4>
                        <div class="quiz-options">
                            ${q.options.map((option, optIndex) => `
                                <div class="quiz-option" onclick="selectQuizAnswer(1, ${index}, ${optIndex}, this)">
                                    ${option}
                                </div>
                            `).join('')}
                        </div>
                        <div class="question-explanation" id="rapidFire${index}Explanation">
                            <strong>Explanation:</strong> ${q.explanation}
                        </div>
                    </div>
                `;
            });
            container.innerHTML = html;
        }

        function generateAdvancedConcepts() {
            const container = document.getElementById('advancedContent');
            if (!container) return;
            
            let html = '';
            selectedQuestions.advanced.forEach((q, index) => {
                html += `
                    <div class="quiz-question">
                        <h4>Question ${index + 1}: ${q.question}</h4>
                        <div class="quiz-options">
                            ${q.options.map((option, optIndex) => `
                                <div class="quiz-option" onclick="selectAdvancedAnswer(${index}, ${optIndex}, this)">
                                    ${option}
                                </div>
                            `).join('')}
                        </div>
                        <div class="question-explanation" id="advanced${index}Explanation">
                            <strong>Explanation:</strong> ${q.explanation}
                        </div>
                    </div>
                `;
            });
            container.innerHTML = html;
        }

        function generateFillInTheBlanks() {
            const container = document.getElementById('fillBlanksContent');
            if (!container) return;
            
            let html = '';
            selectedQuestions.fillBlanks.forEach((q, index) => {
                let processedText = q.text;
                q.blanks.forEach((blank, blankIndex) => {
                    const inputId = `fillBlank_${index}_${blankIndex}`;
                    processedText = processedText.replace('_____', 
                        `<input type="text" class="fill-blank-input" id="${inputId}" placeholder="?">`);
                });
                
                html += `
                    <div class="fill-blank-container">
                        <div class="fill-blank-text">${processedText}</div>
                        <div class="question-explanation" id="fillBlank${index}Explanation">
                            <strong>Explanation:</strong> ${q.explanation}
                        </div>
                    </div>
                `;
            });
            container.innerHTML = html;
        }

        function generateCalculationChallenge() {
            const container = document.getElementById('calculationContent');
            if (!container) return;
            
            let html = '';
            selectedQuestions.calculations.forEach((q, index) => {
                const inputId = `calc_${index}`;
                html += `
                    <div class="fill-blank-container">
                        <h4>Problem ${index + 1}:</h4>
                        <p>${q.question}</p>
                        <div style="margin: 15px 0;">
                            <label>Answer: </label>
                            <input type="number" class="fill-blank-input" id="${inputId}" step="0.01" style="width: 100px;">
                            <span style="margin-left: 5px;">${q.unit}</span>
                        </div>
                        <div class="question-explanation" id="calc${index}Explanation">
                            <strong>Explanation:</strong> ${q.explanation}
                        </div>
                    </div>
                `;
            });
            container.innerHTML = html;
        }

        function generateMatching() {
            const container = document.getElementById('matchingContent');
            if (!container) return;
            
            if (selectedQuestions.matching.length === 0) return;
            
            const matchingData = selectedQuestions.matching[0];
            let html = `
                <div class="matching-container" id="matchingContainer">
                    <svg class="matching-lines-svg" id="matchingLinesSvg">
                        <!-- Connection lines will be drawn here -->
                    </svg>
                    <div class="matching-column">
                        <h4>Terms</h4>
                        ${matchingData.terms.map((term, index) => `
                            <div class="matching-item" data-type="term" data-id="${index}" onclick="selectMatchingItem(this)">
                                ${term}
                            </div>
                        `).join('')}
                    </div>
                    <div class="matching-column">
                        <h4>Definitions</h4>
                        ${matchingData.definitions.map((def, index) => `
                            <div class="matching-item" data-type="definition" data-id="${index}" onclick="selectMatchingItem(this)">
                                ${def}
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
            container.innerHTML = html;
        }

        function selectQuizAnswer(challengeNum, questionNum, answer, element) {
            challengeAnswers.rapidFire[questionNum] = answer;
            
            // Remove previous selections
            const options = element.parentNode.querySelectorAll('.quiz-option');
            options.forEach(opt => opt.classList.remove('selected'));
            
            // Mark current selection
            element.classList.add('selected');
        }

        function selectAdvancedAnswer(questionNum, answer, element) {
            challengeAnswers.advanced[questionNum] = answer;
            
            // Remove previous selections
            const options = element.parentNode.querySelectorAll('.quiz-option');
            options.forEach(opt => opt.classList.remove('selected'));
            
            // Mark current selection
            element.classList.add('selected');
        }

        function selectMatchingItem(element) {
            if (element.classList.contains('matched')) return;
            
            if (selectedMatchingItems.length === 0) {
                selectedMatchingItems.push(element);
                element.classList.add('selected');
            } else if (selectedMatchingItems.length === 1) {
                if (selectedMatchingItems[0] === element) {
                    // Deselect
                    selectedMatchingItems = [];
                    element.classList.remove('selected');
                } else if (selectedMatchingItems[0].dataset.type !== element.dataset.type) {
                    // Valid pair
                    selectedMatchingItems.push(element);
                    createMatchingPair(selectedMatchingItems[0], selectedMatchingItems[1]);
                    selectedMatchingItems = [];
                } else {
                    // Same type, replace selection
                    selectedMatchingItems[0].classList.remove('selected');
                    selectedMatchingItems = [element];
                    element.classList.add('selected');
                }
            }
        }

        function createMatchingPair(item1, item2) {
            const connectionId = currentConnectionId++;
            
            item1.classList.remove('selected');
            item2.classList.remove('selected');
            item1.classList.add('matched');
            item2.classList.add('matched');
            
            // Store the connection
            connectionLines[connectionId] = { item1, item2, connectionId };
            
            // Draw connection line with a small delay to ensure proper positioning
            setTimeout(() => drawConnectionLine(item1, item2, connectionId), 10);
            
            // Add remove button
            const removeBtn = document.createElement('span');
            removeBtn.innerHTML = ' ✕';
            removeBtn.style.cursor = 'pointer';
            removeBtn.style.color = '#ef4444';
            removeBtn.style.fontWeight = 'bold';
            removeBtn.style.marginLeft = '10px';
            removeBtn.onclick = (e) => {
                e.stopPropagation();
                removeMatchingPair(connectionId);
            };
            item1.appendChild(removeBtn);
        }

        function drawConnectionLine(item1, item2, connectionId) {
            const svg = document.getElementById('matchingLinesSvg');
            if (!svg) return;

            const container = document.getElementById('matchingContainer');
            if (!container) return;

            const containerRect = container.getBoundingClientRect();
            const item1Rect = item1.getBoundingClientRect();
            const item2Rect = item2.getBoundingClientRect();

            // Calculate relative positions
            const x1 = item1Rect.right - containerRect.left;
            const y1 = item1Rect.top - containerRect.top + item1Rect.height / 2;
            const x2 = item2Rect.left - containerRect.left;
            const y2 = item2Rect.top - containerRect.top + item2Rect.height / 2;

            // Create line element
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', x1);
            line.setAttribute('y1', y1);
            line.setAttribute('x2', x2);
            line.setAttribute('y2', y2);
            line.setAttribute('class', 'connection-line');
            line.setAttribute('data-connection-id', connectionId);

            svg.appendChild(line);
        }

        function updateAllConnectionLines() {
            const svg = document.getElementById('matchingLinesSvg');
            if (!svg) return;

            Object.values(connectionLines).forEach(connection => {
                const line = svg.querySelector(`[data-connection-id="${connection.connectionId}"]`);
                if (line) {
                    const container = document.getElementById('matchingContainer');
                    if (!container) return;

                    const containerRect = container.getBoundingClientRect();
                    const item1Rect = connection.item1.getBoundingClientRect();
                    const item2Rect = connection.item2.getBoundingClientRect();

                    // Calculate relative positions
                    const x1 = item1Rect.right - containerRect.left;
                    const y1 = item1Rect.top - containerRect.top + item1Rect.height / 2;
                    const x2 = item2Rect.left - containerRect.left;
                    const y2 = item2Rect.top - containerRect.top + item2Rect.height / 2;

                    line.setAttribute('x1', x1);
                    line.setAttribute('y1', y1);
                    line.setAttribute('x2', x2);
                    line.setAttribute('y2', y2);
                }
            });
        }

        function removeMatchingPair(connectionId) {
            const connection = connectionLines[connectionId];
            if (connection) {
                connection.item1.classList.remove('matched', 'correct-match', 'incorrect-match');
                connection.item2.classList.remove('matched', 'correct-match', 'incorrect-match');
                
                // Remove the X button
                const removeBtn = connection.item1.querySelector('span');
                if (removeBtn) removeBtn.remove();
                
                // Remove the visual line
                const svg = document.getElementById('matchingLinesSvg');
                if (svg) {
                    const line = svg.querySelector(`[data-connection-id="${connectionId}"]`);
                    if (line) line.remove();
                }
                
                delete connectionLines[connectionId];
            }
        }

        function checkQuizAnswers(challengeNum) {
            const questions = selectedQuestions.rapidFire;
            let correct = 0;
            let total = questions.length;
            
            questions.forEach((q, index) => {
                const userAnswer = challengeAnswers.rapidFire[index];
                const explanationDiv = document.getElementById(`rapidFire${index}Explanation`);
                
                if (userAnswer === q.correct) {
                    correct++;
                    explanationDiv.classList.add('active');
                    explanationDiv.style.background = '#f0fdf4';
                    explanationDiv.style.borderLeft = '4px solid #16a34a';
                } else {
                    explanationDiv.classList.add('active');
                    explanationDiv.style.background = '#fef2f2';
                    explanationDiv.style.borderLeft = '4px solid #ef4444';
                }
            });
            
            const score = Math.round((correct / total) * 100);
            const feedback = document.getElementById('challenge1Feedback');
            
            if (score >= 70) {
                feedback.className = 'challenge-feedback success';
                feedback.innerHTML = `🎉 Excellent! You scored ${score}% (${correct}/${total})`;
                markChallengeComplete(1, score);
            } else {
                feedback.className = 'challenge-feedback error';
                feedback.innerHTML = `📚 Keep studying! You scored ${score}% (${correct}/${total}). Try again!`;
            }
            feedback.style.display = 'block';
        }

        function checkAdvancedAnswers() {
            const questions = selectedQuestions.advanced;
            let correct = 0;
            let total = questions.length;
            
            questions.forEach((q, index) => {
                const userAnswer = challengeAnswers.advanced[index];
                const explanationDiv = document.getElementById(`advanced${index}Explanation`);
                
                if (userAnswer === q.correct) {
                    correct++;
                    explanationDiv.classList.add('active');
                    explanationDiv.style.background = '#f0fdf4';
                    explanationDiv.style.borderLeft = '4px solid #16a34a';
                } else {
                    explanationDiv.classList.add('active');
                    explanationDiv.style.background = '#fef2f2';
                    explanationDiv.style.borderLeft = '4px solid #ef4444';
                }
            });
            
            const score = Math.round((correct / total) * 100);
            const feedback = document.getElementById('challenge2Feedback');
            
            if (score >= 70) {
                feedback.className = 'challenge-feedback success';
                feedback.innerHTML = `🎉 Outstanding! You scored ${score}% (${correct}/${total})`;
                markChallengeComplete(2, score);
            } else {
                feedback.className = 'challenge-feedback error';
                feedback.innerHTML = `📚 Keep learning! You scored ${score}% (${correct}/${total}). Try again!`;
            }
            feedback.style.display = 'block';
        }

        function checkFillBlanks() {
            const questions = selectedQuestions.fillBlanks;
            let correct = 0;
            let total = 0;
            
            questions.forEach((q, qIndex) => {
                q.blanks.forEach((correctAnswer, blankIndex) => {
                    total++;
                    const inputId = `fillBlank_${qIndex}_${blankIndex}`;
                    const input = document.getElementById(inputId);
                    const userAnswer = input ? input.value.trim() : '';
                    
                    if (userAnswer.toLowerCase() === correctAnswer.toLowerCase()) {
                        correct++;
                        if (input) {
                            input.classList.add('correct');
                            input.classList.remove('incorrect');
                        }
                    } else {
                        if (input) {
                            input.classList.add('incorrect');
                            input.classList.remove('correct');
                        }
                    }
                });
                
                const explanationDiv = document.getElementById(`fillBlank${qIndex}Explanation`);
                explanationDiv.classList.add('active');
            });
            
            const score = Math.round((correct / total) * 100);
            const feedback = document.getElementById('challenge3Feedback');
            
            if (score >= 70) {
                feedback.className = 'challenge-feedback success';
                feedback.innerHTML = `🎉 Great work! You got ${correct}/${total} blanks correct (${score}%)`;
                markChallengeComplete(3, score);
            } else {
                feedback.className = 'challenge-feedback error';
                feedback.innerHTML = `📝 Try again! You got ${correct}/${total} blanks correct (${score}%)`;
            }
            feedback.style.display = 'block';
        }

        function checkCalculations() {
            const questions = selectedQuestions.calculations;
            let correct = 0;
            let total = questions.length;
            
            questions.forEach((q, index) => {
                const inputId = `calc_${index}`;
                const input = document.getElementById(inputId);
                const userAnswer = input ? parseFloat(input.value) : NaN;
                const correctAnswer = parseFloat(q.answer);
                
                const explanationDiv = document.getElementById(`calc${index}Explanation`);
                explanationDiv.classList.add('active');
                
                if (!isNaN(userAnswer) && Math.abs(userAnswer - correctAnswer) <= q.tolerance) {
                    correct++;
                    if (input) {
                        input.classList.add('correct');
                        input.classList.remove('incorrect');
                    }
                    explanationDiv.style.background = '#f0fdf4';
                    explanationDiv.style.borderLeft = '4px solid #16a34a';
                } else {
                    if (input) {
                        input.classList.add('incorrect');
                        input.classList.remove('correct');
                    }
                    explanationDiv.style.background = '#fef2f2';
                    explanationDiv.style.borderLeft = '4px solid #ef4444';
                }
            });
            
            const score = Math.round((correct / total) * 100);
            const feedback = document.getElementById('challenge4Feedback');
            
            if (score >= 70) {
                feedback.className = 'challenge-feedback success';
                feedback.innerHTML = `🎉 Excellent calculations! You got ${correct}/${total} problems correct (${score}%)`;
                markChallengeComplete(4, score);
            } else {
                feedback.className = 'challenge-feedback error';
                feedback.innerHTML = `🧮 Check your work! You got ${correct}/${total} problems correct (${score}%)`;
            }
            feedback.style.display = 'block';
        }

        function checkMatching() {
            if (selectedQuestions.matching.length === 0) return;
            
            const matchingData = selectedQuestions.matching[0];
            let correct = 0;
            let total = matchingData.terms.length;
            const svg = document.getElementById('matchingLinesSvg');
            
            // Check each connection
            Object.values(connectionLines).forEach(connection => {
                const termId = parseInt(connection.item1.dataset.type === 'term' ? 
                    connection.item1.dataset.id : connection.item2.dataset.id);
                const defId = parseInt(connection.item1.dataset.type === 'definition' ? 
                    connection.item1.dataset.id : connection.item2.dataset.id);
                
                const line = svg ? svg.querySelector(`[data-connection-id="${connection.connectionId}"]`) : null;
                
                if (termId === defId) {
                    correct++;
                    connection.item1.classList.add('correct-match');
                    connection.item2.classList.add('correct-match');
                    if (line) line.classList.add('correct');
                } else {
                    connection.item1.classList.add('incorrect-match');
                    connection.item2.classList.add('incorrect-match');
                    if (line) line.classList.add('incorrect');
                }
            });
            
            // Show answer key
            showAnswerKey(matchingData);
            
            const score = Math.round((correct / total) * 100);
            const feedback = document.getElementById('challenge5Feedback');
            
            if (score >= 70) {
                feedback.className = 'challenge-feedback success';
                feedback.innerHTML = `🎉 Perfect matching! You got ${correct}/${total} pairs correct (${score}%)`;
                markChallengeComplete(5, score);
            } else {
                feedback.className = 'challenge-feedback error';
                feedback.innerHTML = `🔗 Try again! You got ${correct}/${total} pairs correct (${score}%)`;
            }
            feedback.style.display = 'block';
        }

        function showAnswerKey(matchingData) {
            const container = document.getElementById('matchingContent');
            if (!container) return;

            // Remove existing answer key
            const existingKey = container.querySelector('.answer-key');
            if (existingKey) existingKey.remove();

            // Create answer key
            let answerKeyHtml = `
                <div class="answer-key active">
                    <h4>📋 Answer Key - Correct Matches:</h4>
            `;

            matchingData.terms.forEach((term, index) => {
                answerKeyHtml += `
                    <div class="answer-pair">
                        <div class="answer-term">${term}</div>
                        <div class="answer-arrow">⟷</div>
                        <div class="answer-definition">${matchingData.definitions[index]}</div>
                    </div>
                `;
            });

            answerKeyHtml += `</div>`;
            
            container.insertAdjacentHTML('beforeend', answerKeyHtml);
        }

        function showMatchingAnswerKey() {
            if (selectedQuestions.matching.length === 0) return;
            
            const matchingData = selectedQuestions.matching[0];
            showAnswerKey(matchingData);
        }

        function showQuizHints(challengeNum) {
            hintsUsed++;
            updateChallengeStats();
            
            const hintDiv = document.getElementById(`challenge${challengeNum}Hint`);
            let hintsText = '<h4>💡 Hints:</h4><ul>';
            
            if (challengeNum === 1) {
                selectedQuestions.rapidFire.forEach((q, index) => {
                    hintsText += `<li><strong>Q${index + 1}:</strong> ${q.hint}</li>`;
                });
            }
            
            hintsText += '</ul>';
            hintDiv.innerHTML = hintsText;
            hintDiv.classList.add('active');
        }

        function showAdvancedHints() {
            hintsUsed++;
            updateChallengeStats();
            
            const hintDiv = document.getElementById('challenge2Hint');
            let hintsText = '<h4>💡 Hints:</h4><ul>';
            
            selectedQuestions.advanced.forEach((q, index) => {
                hintsText += `<li><strong>Q${index + 1}:</strong> ${q.hint}</li>`;
            });
            
            hintsText += '</ul>';
            hintDiv.innerHTML = hintsText;
            hintDiv.classList.add('active');
        }

        function showFillBlanksHint() {
            hintsUsed++;
            updateChallengeStats();
            
            const hintDiv = document.getElementById('challenge3Hint');
            let hintsText = '<h4>💡 Hints:</h4><ul>';
            
            selectedQuestions.fillBlanks.forEach((q, index) => {
                hintsText += `<li><strong>Statement ${index + 1}:</strong> ${q.hint}</li>`;
            });
            
            hintsText += '</ul>';
            hintDiv.innerHTML = hintsText;
            hintDiv.classList.add('active');
        }

        function showCalculationHint() {
            hintsUsed++;
            updateChallengeStats();
            
            const hintDiv = document.getElementById('challenge4Hint');
            let hintsText = '<h4>💡 Hints:</h4><ul>';
            
            selectedQuestions.calculations.forEach((q, index) => {
                hintsText += `<li><strong>Problem ${index + 1}:</strong> ${q.hint}</li>`;
            });
            
            hintsText += '</ul>';
            hintDiv.innerHTML = hintsText;
            hintDiv.classList.add('active');
        }

        function showMatchingHints() {
            hintsUsed++;
            updateChallengeStats();
            
            const hintDiv = document.getElementById('challenge5Hint');
            hintDiv.innerHTML = `
                <h4>💡 Hint:</h4>
                <p>Match each term with its corresponding definition. Think about the fundamental concepts of Schottky junctions.</p>
            `;
            hintDiv.classList.add('active');
        }

        function markChallengeComplete(challengeNum, points) {
            challengeStates[challengeNum].completed = true;
            challengeStates[challengeNum].score = Math.max(challengeStates[challengeNum].score, points);
            
            document.getElementById(`challenge${challengeNum}`).classList.add('completed');
            
            updateChallengeStats();
        }

        function resetChallenge(challengeNum) {
            challengeStates[challengeNum].completed = false;
            challengeStates[challengeNum].score = 0;
            
            document.getElementById(`challenge${challengeNum}`).classList.remove('completed');
            
            // Reset UI elements
            const feedback = document.getElementById(`challenge${challengeNum}Feedback`);
            if (feedback) feedback.style.display = 'none';
            
            const hint = document.getElementById(`challenge${challengeNum}Hint`);
            if (hint) hint.classList.remove('active');
            
            // Reset answers
            if (challengeNum === 1) {
                challengeAnswers.rapidFire.fill(null);
                document.querySelectorAll('#rapidFireContent .quiz-option').forEach(opt => {
                    opt.classList.remove('selected', 'correct', 'incorrect');
                });
                document.querySelectorAll('#rapidFireContent .question-explanation').forEach(exp => {
                    exp.classList.remove('active');
                });
            } else if (challengeNum === 2) {
                challengeAnswers.advanced.fill(null);
                document.querySelectorAll('#advancedContent .quiz-option').forEach(opt => {
                    opt.classList.remove('selected', 'correct', 'incorrect');
                });
                document.querySelectorAll('#advancedContent .question-explanation').forEach(exp => {
                    exp.classList.remove('active');
                });
            } else if (challengeNum === 3) {
                document.querySelectorAll('#fillBlanksContent .fill-blank-input').forEach(input => {
                    input.value = '';
                    input.classList.remove('correct', 'incorrect');
                });
                document.querySelectorAll('#fillBlanksContent .question-explanation').forEach(exp => {
                    exp.classList.remove('active');
                });
            } else if (challengeNum === 4) {
                document.querySelectorAll('#calculationContent input').forEach(input => {
                    input.value = '';
                    input.classList.remove('correct', 'incorrect');
                });
                document.querySelectorAll('#calculationContent .question-explanation').forEach(exp => {
                    exp.classList.remove('active');
                });
            } else if (challengeNum === 5) {
                // Reset matching
                selectedMatchingItems = [];
                Object.keys(connectionLines).forEach(id => removeMatchingPair(parseInt(id)));
                document.querySelectorAll('#matchingContent .matching-item').forEach(item => {
                    item.classList.remove('selected', 'matched', 'correct-match', 'incorrect-match');
                    const removeBtn = item.querySelector('span');
                    if (removeBtn) removeBtn.remove();
                });
                // Remove answer key
                const answerKey = document.querySelector('#matchingContent .answer-key');
                if (answerKey) answerKey.remove();
            }
            
            updateChallengeStats();
        }

        function updateChallengeStats() {
            challengesSolved = Object.values(challengeStates).filter(state => state.completed).length;
            totalScore = Object.values(challengeStates).reduce((sum, state) => sum + state.score, 0);
            const averageScore = challengesSolved > 0 ? Math.round(totalScore / challengesSolved) : 100;
            
            safeSetValue('totalScore', totalScore);
            safeSetValue('challengesSolved', challengesSolved);
            safeSetValue('hintsUsed', hintsUsed);
            safeSetValue('accuracy', averageScore + '%');
            
            // Update progress bar
            const progress = (challengesSolved / 5) * 100;
            const progressBar = document.getElementById('overallProgress');
            if (progressBar) {
                progressBar.style.width = progress + '%';
            }
        }

        function resetAllChallenges() {
            for (let i = 1; i <= 5; i++) {
                resetChallenge(i);
            }
            totalScore = 0;
            challengesSolved = 0;
            hintsUsed = 0;
            
            // Don't regenerate questions, just reset the current ones
            resetAllChallengeUI();
            updateChallengeStats();
        }

        function showCompletionModal() {
            alert(`🏆 Challenge Progress 🏆\n\nChallenges Completed: ${challengesSolved}/5\nTotal Score: ${totalScore}\nHints Used: ${hintsUsed}\n\n${challengesSolved === 5 ? 'Congratulations! You\'ve completed all challenges!' : 'Keep going! You\'re doing great!'}`);
        }

        function generateNewQuestions() {
            // Reset all challenge states
            for (let i = 1; i <= 5; i++) {
                challengeStates[i].completed = false;
                challengeStates[i].score = 0;
                document.getElementById(`challenge${i}`).classList.remove('completed');
                
                // Reset UI elements
                const feedback = document.getElementById(`challenge${i}Feedback`);
                if (feedback) feedback.style.display = 'none';
                
                const hint = document.getElementById(`challenge${i}Hint`);
                if (hint) hint.classList.remove('active');
            }
            
            // Reset challenge stats
            totalScore = 0;
            challengesSolved = 0;
            hintsUsed = 0;
            
            // Generate new questions
            selectRandomQuestions();
            generateChallengeContent();
            
            // Reset all challenge UI states
            resetAllChallengeUI();
            
            // Update stats
            updateChallengeStats();
            
            // Show confirmation
            alert('🎲 New questions generated! All challenges have been reset with fresh questions from the question bank.');
        }

        function resetAllChallengeUI() {
            // Reset rapid fire
            document.querySelectorAll('#rapidFireContent .quiz-option').forEach(opt => {
                opt.classList.remove('selected', 'correct', 'incorrect');
            });
            document.querySelectorAll('#rapidFireContent .question-explanation').forEach(exp => {
                exp.classList.remove('active');
                exp.style.background = '';
                exp.style.borderLeft = '';
            });
            
            // Reset advanced
            document.querySelectorAll('#advancedContent .quiz-option').forEach(opt => {
                opt.classList.remove('selected', 'correct', 'incorrect');
            });
            document.querySelectorAll('#advancedContent .question-explanation').forEach(exp => {
                exp.classList.remove('active');
                exp.style.background = '';
                exp.style.borderLeft = '';
            });
            
            // Reset fill blanks
            document.querySelectorAll('#fillBlanksContent .fill-blank-input').forEach(input => {
                input.value = '';
                input.classList.remove('correct', 'incorrect');
            });
            document.querySelectorAll('#fillBlanksContent .question-explanation').forEach(exp => {
                exp.classList.remove('active');
            });
            
            // Reset calculations
            document.querySelectorAll('#calculationContent input').forEach(input => {
                input.value = '';
                input.classList.remove('correct', 'incorrect');
            });
            document.querySelectorAll('#calculationContent .question-explanation').forEach(exp => {
                exp.classList.remove('active');
                exp.style.background = '';
                exp.style.borderLeft = '';
            });
            
            // Reset matching
            selectedMatchingItems = [];
            Object.keys(connectionLines).forEach(id => removeMatchingPair(parseInt(id)));
            document.querySelectorAll('#matchingContent .matching-item').forEach(item => {
                item.classList.remove('selected', 'matched', 'correct-match', 'incorrect-match');
                const removeBtn = item.querySelector('span');
                if (removeBtn) removeBtn.remove();
            });
            const answerKey = document.querySelector('#matchingContent .answer-key');
            if (answerKey) answerKey.remove();
            
            // Reset challenge answers
            challengeAnswers = {
                rapidFire: new Array(selectedQuestions.rapidFire.length).fill(null),
                advanced: new Array(selectedQuestions.advanced.length).fill(null),
                fillBlanks: {},
                calculations: {},
                matching: {}
            };
        }

        // Initialize the simulation
        function init() {
            console.log('Initializing simulation...');
            createParticles();
            setupEventListeners();
            updateParameters();
            updateEquilibriumVisualization();
            
            // Initialize challenges
            selectRandomQuestions();
            generateChallengeContent();
            updateChallengeStats();
        }

        // Create background particles
        function createParticles() {
            const particlesContainer = safeGetElement('particles');
            if (!particlesContainer) return;

            for (let i = 0; i < 50; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.left = Math.random() * 100 + '%';
                particle.style.top = Math.random() * 100 + '%';
                particle.style.animationDelay = Math.random() * 6 + 's';
                particle.style.animationDuration = (6 + Math.random() * 4) + 's';
                particlesContainer.appendChild(particle);
            }
        }

        // Tab switching
        function switchTab(tabName) {
            console.log('Switching to tab:', tabName);
            
            // Update tab buttons
            document.querySelectorAll('.nav-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');
            
            // Update content
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            document.getElementById(tabName).classList.add('active');
            
            currentTab = tabName;
            
            // Initialize content based on tab
            switch(tabName) {
                case 'equilibrium':
                    updateEquilibriumVisualization();
                    break;
                case 'biasing':
                    updateBiasingVisualization();
                    break;
                case 'applications':
                    showHideApplicationControls();
                    updateApplicationsVisualization(); // This will now auto-start the simulation
                    break;
                case 'challenges':
                    if (!selectedQuestions.rapidFire || selectedQuestions.rapidFire.length === 0) {
                        selectRandomQuestions();
                        generateChallengeContent();
                    }
                    break;
            }
        }

        // Setup event listeners
        function setupEventListeners() {
            console.log('Setting up event listeners...');
            
            // Tab navigation
            document.querySelectorAll('.nav-tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    const tabName = tab.getAttribute('data-tab');
                    switchTab(tabName);
                });
            });

            // Equilibrium controls
            const equilibriumControls = ['workFunction', 'semiconductorType', 'dopingConc', 'temperature'];
            equilibriumControls.forEach(controlId => {
                const control = safeGetElement(controlId);
                if (control) {
                    control.addEventListener('input', () => {
                        updateParameters();
                        if (currentTab === 'equilibrium') {
                            updateEquilibriumVisualization();
                        }
                    });
                }
            });

            // Biasing controls
            const biasVoltage = safeGetElement('biasVoltage');
            if (biasVoltage) {
                biasVoltage.addEventListener('input', () => {
                    updateBiasingParameters();
                    if (currentTab === 'biasing') {
                        updateBiasingVisualization();
                    }
                });
            }

            // Applications controls - handle each type specifically to avoid conflicts
            
            // Frequency control - real-time updates, no demo restart
            const signalFreq = safeGetElement('signalFreq');
            if (signalFreq) {
                signalFreq.addEventListener('input', () => {
                    updateApplicationsParameters();
                    // Don't call updateApplicationsVisualization() to avoid recreating canvas
                    // The animation loop will pick up the new frequency automatically
                });
            }

            // Load resistance control - real-time updates, no demo restart
            const loadResistance = safeGetElement('loadResistance');
            if (loadResistance) {
                loadResistance.addEventListener('input', () => {
                    updateApplicationsParameters();
                    // Don't call updateApplicationsVisualization() to avoid recreating canvas
                    // The animation loop will pick up the new load resistance automatically
                });
            }

            // Capacitance control - only restart if capacitor is enabled
            const capacitance = safeGetElement('capacitance');
            if (capacitance) {
                capacitance.addEventListener('input', () => {
                    updateApplicationsParameters();
                    // Don't call updateApplicationsVisualization() to avoid recreating canvas
                    // The animation loop will pick up the new capacitance automatically
                    if (currentTab === 'applications') {
                        // Only reset capacitor state if capacitor is enabled and demo is running
                        if (isDemoRunning && safeGetElement('applicationType')?.value === 'rectifier') {
                            const capacitorEnabled = safeGetElement('addCapacitor')?.checked || false;
                            if (capacitorEnabled) {
                                // Reset capacitor state for new capacitance value
                                window.capacitorVoltage = 0;
                            }
                        }
                    }
                });
            }

            // Capacitor checkbox - restart demo when toggled
            const addCapacitor = safeGetElement('addCapacitor');
            if (addCapacitor) {
                addCapacitor.addEventListener('change', () => {
                    const capacitorSlider = safeGetElement('capacitance');
                    if (capacitorSlider) {
                        capacitorSlider.disabled = !addCapacitor.checked;
                    }
                    updateApplicationsParameters();
                    if (currentTab === 'applications') {
                        // Reset capacitor state for new configuration without recreating canvas
                        if (isDemoRunning && safeGetElement('applicationType')?.value === 'rectifier') {
                            window.capacitorVoltage = 0;
                            window.prevRectifierType = safeGetElement('rectifierType')?.value || 'half-wave';
                            window.prevCapacitorState = safeGetElement('addCapacitor')?.checked || false;
                        }
                    }
                });
            }

            // Application type control - restart demo when changed
            const applicationType = safeGetElement('applicationType');
            if (applicationType) {
                applicationType.addEventListener('change', () => {
                    showHideApplicationControls();
                    updateApplicationsParameters();
                    if (currentTab === 'applications') {
                        // Reset demo state when switching application types
                        if (isDemoRunning) {
                            window.capacitorVoltage = 0;
                            window.prevRectifierType = safeGetElement('rectifierType')?.value || 'half-wave';
                            window.prevCapacitorState = safeGetElement('addCapacitor')?.checked || false;
                        }
                        updateApplicationsVisualization();
                    }
                });
            }

            // Rectifier type control - restart demo when changed
            const rectifierType = safeGetElement('rectifierType');
            if (rectifierType) {
                rectifierType.addEventListener('change', () => {
                    updateApplicationsParameters();
                    if (currentTab === 'applications') {
                        // Reset demo state when switching rectifier types
                        if (isDemoRunning) {
                            window.capacitorVoltage = 0;
                            window.prevRectifierType = safeGetElement('rectifierType')?.value || 'half-wave';
                            window.prevCapacitorState = safeGetElement('addCapacitor')?.checked || false;
                        }
                        // Update visualization to show new circuit diagram
                        updateApplicationsVisualization();
                    }
                });
            }

            // Add event listeners for real-time parameter changes
            const realTimeParams = ['signalFreq', 'capacitance', 'loadResistance'];
            realTimeParams.forEach(paramId => {
                const control = safeGetElement(paramId);
                if (control) {
                    control.addEventListener('input', () => {
                        updateApplicationsParameters();
                        if (currentTab === 'applications' && isDemoRunning) {
                            // Just updating parameters is enough - drawWaves will use new values
                        }
                    });
                }
            });

            // Add resize event listener to update connection lines
            window.addEventListener('resize', () => {
                if (currentTab === 'challenges') {
                    setTimeout(updateAllConnectionLines, 100);
                }
            });
        }

        // Show/hide application-specific controls
        function showHideApplicationControls() {
            const applicationType = safeGetElement('applicationType')?.value || 'rectifier';
            const rectifierControls = safeGetElement('rectifierControls');
            
            if (rectifierControls) {
                rectifierControls.style.display = applicationType === 'rectifier' ? 'block' : 'none';
            }
        }

        // Calculate junction parameters
        function calculateJunctionParameters() {
            const workFunction = safeGetValue('workFunction', 4.5);
            const semiconductorType = safeGetElement('semiconductorType')?.value || 'n-type';
            const dopingConc = safeGetValue('dopingConc', 16);
            const temperature = safeGetValue('temperature', 300);

            const Nd = Math.pow(10, dopingConc);
            
            let barrierHeight, builtInPotential;
            
            if (semiconductorType === 'n-type') {
                barrierHeight = Math.max(0.1, workFunction - CONSTANTS.Si_EA);
                builtInPotential = Math.max(0.1, barrierHeight - CONSTANTS.k * temperature * Math.log(CONSTANTS.Nc / Nd));
            } else {
                barrierHeight = Math.max(0.1, CONSTANTS.Si_Eg + CONSTANTS.Si_EA - workFunction);
                builtInPotential = Math.max(0.1, barrierHeight - CONSTANTS.k * temperature * Math.log(CONSTANTS.Nv / Nd));
            }

            // Ensure physical values
            builtInPotential = Math.min(barrierHeight * 0.9, builtInPotential);

            // Calculate depletion width
            const W = Math.sqrt(2 * CONSTANTS.eps_si * CONSTANTS.eps_0 * builtInPotential / (CONSTANTS.q * Nd)) * 1e4; // in μm

            // Calculate maximum electric field
            const Emax = 2 * builtInPotential / (W * 1e-4); // in V/cm

            return {
                barrierHeight,
                builtInPotential,
                depletionWidth: W,
                maxElectricField: Emax,
                dopingConcentration: Nd,
                temperature
            };
        }

        // Update equilibrium parameters
        function updateParameters() {
            const workFunction = safeGetValue('workFunction', 4.5);
            const dopingConc = safeGetValue('dopingConc', 16);
            const temperature = safeGetValue('temperature', 300);

            // Update display values
            safeSetValue('workFunctionValue', workFunction.toFixed(1) + ' eV');
            safeSetValue('dopingValue', '10¹' + dopingConc.toFixed(0) + ' cm⁻³');
            safeSetValue('tempValue', temperature + ' K');

            const params = calculateJunctionParameters();

            // Update measurements
            safeSetValue('barrierHeight', params.barrierHeight.toFixed(2) + ' eV');
            safeSetValue('builtInPotential', params.builtInPotential.toFixed(2) + ' V');
            safeSetValue('depletionWidth', params.depletionWidth.toFixed(2) + ' μm');
            safeSetValue('maxElectricField', params.maxElectricField.toExponential(1) + ' V/cm');
        }

        // Update biasing parameters
        function updateBiasingParameters() {
            const biasVoltage = safeGetValue('biasVoltage', 0);
            
            safeSetValue('biasValue', biasVoltage.toFixed(1) + ' V');
            
            // Determine bias condition
            let condition;
            if (biasVoltage > 0.1) {
                condition = 'Forward Bias';
            } else if (biasVoltage < -0.1) {
                condition = 'Reverse Bias';
            } else {
                condition = 'Equilibrium';
            }
            
            safeSetValue('biasCondition', condition);

            const params = calculateJunctionParameters();
            const idealityFactor = 1.2;

            // Calculate current density using thermionic emission theory
            const J0 = CONSTANTS.A_star * Math.pow(params.temperature, 2) * Math.exp(-params.barrierHeight / (CONSTANTS.k * params.temperature));
            const J = J0 * (Math.exp(biasVoltage / (idealityFactor * CONSTANTS.k * params.temperature)) - 1);

            safeSetValue('currentDensity', J.toExponential(2) + ' A/cm²');
            
            // Calculate effective barrier
            const effectiveBarrier = Math.max(0, params.barrierHeight - biasVoltage);
            safeSetValue('effectiveBarrier', effectiveBarrier.toFixed(2) + ' eV');

            // Calculate depletion width change
            const effectivePotential = Math.max(0.01, params.builtInPotential - biasVoltage);
            const depletionChange = (Math.sqrt(effectivePotential) / Math.sqrt(params.builtInPotential) - 1) * 100;
            safeSetValue('depletionChange', depletionChange.toFixed(1) + '%');
        }

        // Update applications parameters
        function updateApplicationsParameters() {
            // Only rectifier applications are supported
            updateRectifierParameters();
        }


        // Update rectifier parameters
        function updateRectifierParameters() {
            const signalFreq = safeGetValue('signalFreq', 60);
            const inputAmplitude = 12; // Fixed at 12V
            const addCapacitor = safeGetElement('addCapacitor')?.checked || false;
            const capacitance = safeGetValue('capacitance', 470);
            const loadResistance = safeGetValue('loadResistance', 100);
            const rectifierType = safeGetElement('rectifierType')?.value || 'half-wave';
            
            safeSetValue('freqValue', signalFreq + ' Hz');
            safeSetValue('capacitanceValue', capacitance + ' μF');
            safeSetValue('loadValue', loadResistance + ' Ω');

            // Calculate rectifier performance parameters
            const Vf = 0.3; // Forward voltage drop of Schottky diode
            let Vdc, rippleFactor, efficiency;

            if (rectifierType === 'half-wave') {
                // Half-wave rectifier calculations
                if (addCapacitor) {
                    // With filter capacitor
                    const RC = loadResistance * capacitance * 1e-6; // RC time constant
                    const T = 1 / signalFreq; // Period
                    Vdc = (inputAmplitude - Vf) * (1 - 1/(2 * signalFreq * RC));
                    rippleFactor = 1 / (2 * Math.sqrt(3) * signalFreq * RC) * 100;
                    efficiency = (Vdc / inputAmplitude) * 100;
                } else {
                    // Without filter capacitor
                    Vdc = (inputAmplitude - Vf) / Math.PI;
                    rippleFactor = 121; // Theoretical ripple factor for half-wave
                    efficiency = 40.6; // Theoretical efficiency
                }
            } else {
                // Full-wave bridge rectifier calculations
                if (addCapacitor) {
                    // With filter capacitor
                    const RC = loadResistance * capacitance * 1e-6;
                    Vdc = (inputAmplitude - 2*Vf) * (1 - 1/(4 * signalFreq * RC));
                    rippleFactor = 1 / (4 * Math.sqrt(3) * signalFreq * RC) * 100;
                    efficiency = (Vdc / inputAmplitude) * 100;
                } else {
                    // Without filter capacitor
                    Vdc = 2 * (inputAmplitude - 2*Vf) / Math.PI;
                    rippleFactor = 48.2; // Theoretical ripple factor for full-wave
                    efficiency = 81.2; // Theoretical efficiency
                }
            }

            // Update measurements display
            safeSetValue('dcVoltage', Vdc.toFixed(1) + ' V');
            safeSetValue('rippleFactor', rippleFactor.toFixed(1) + '%');
            safeSetValue('efficiency', efficiency.toFixed(1) + '%');
        }

        // Generate charge carriers
        function generateChargeCarriers(region, count = 6) {
            let carriers = '';
            
            for (let i = 0; i < count; i++) {
                const x = 15 + (70 / Math.max(count, 1)) * i;
                const y = 25 + Math.random() * 50;
                const delay = Math.random() * 2;
                
                if (region === 'metal') {
                    carriers += `<div class="charge-carrier electron" style="left: ${x}%; top: ${y}%; animation-delay: ${delay}s;"></div>`;
                } else {
                    const carrierType = Math.random() > 0.6 ? 'hole' : 'electron';
                    carriers += `<div class="charge-carrier ${carrierType}" style="left: ${x}%; top: ${y}%; animation-delay: ${delay}s;"></div>`;
                }
            }
            
            return carriers;
        }

        // Equilibrium visualization
        function updateEquilibriumVisualization() {
            const canvas = safeGetElement('equilibriumCanvas');
            if (!canvas) return;

            const params = calculateJunctionParameters();
            const semiconductorType = safeGetElement('semiconductorType')?.value || 'n-type';

            canvas.innerHTML = `
                <div style="position: relative; width: 100%; height: 100%; padding: 20px;">
                    <!-- Metal region -->
                    <div class="junction-region metal-region" style="left: 5%; top: 10%; width: 25%; height: 35%; color: white; font-weight: 600;">
                        <div>
                            <div>Metal</div>
                            <div style="font-size: 0.8em; opacity: 0.8;">φₘ = ${safeGetElement('workFunctionValue')?.textContent || '4.5 eV'}</div>
                        </div>
                        ${generateChargeCarriers('metal', 8)}
                    </div>

                    <!-- Depletion region -->
                    <div class="junction-region depletion-region" style="left: 30%; top: 10%; width: 15%; height: 35%; color: white; font-weight: 600;">
                        <div style="font-size: 0.9em;">Depletion</div>
                        ${generateDepletionCharges()}
                    </div>

                    <!-- Semiconductor region -->
                    <div class="junction-region semiconductor-region" style="left: 45%; top: 10%; width: 50%; height: 35%; color: white; font-weight: 600;">
                        <div>
                            <div>${semiconductorType.toUpperCase()} Semiconductor</div>
                            <div style="font-size: 0.8em; opacity: 0.8;">Nₐ = ${safeGetElement('dopingValue')?.textContent || '10¹⁶ cm⁻³'}</div>
                        </div>
                        ${generateChargeCarriers('semiconductor', 6)}
                    </div>

                    <!-- Energy band diagram -->
                    <div style="position: absolute; left: 5%; top: 55%; width: 90%; height: 40%; background: rgba(255,255,255,0.05); border-radius: 10px; border: 1px solid rgba(255,255,255,0.1); padding: 15px;">
                        <div style="color: #94a3b8; font-weight: 600; margin-bottom: 10px; text-align: center;">Energy Band Diagram</div>
                        ${generateEnergyBands(params)}
                    </div>
                </div>
            `;
        }

        // Generate depletion region charges
        function generateDepletionCharges() {
            let charges = '';
            const positions = [
                {x: 20, y: 30, charge: '+'},
                {x: 45, y: 45, charge: '-'},
                {x: 70, y: 25, charge: '+'},
                {x: 25, y: 60, charge: '-'}
            ];
            
            positions.forEach(pos => {
                const color = pos.charge === '+' ? '#ef4444' : '#3b82f6';
                charges += `
                    <div style="position: absolute; left: ${pos.x}%; top: ${pos.y}%; width: 12px; height: 12px; border-radius: 50%; background: ${color}; color: white; display: flex; align-items: center; justify-content: center; font-size: 10px; font-weight: bold; box-shadow: 0 0 8px ${color};">
                        ${pos.charge}
                    </div>
                `;
            });
            
            return charges;
        }

        // Generate energy bands with proper physics
        function generateEnergyBands(params) {
            const semiconductorType = safeGetElement('semiconductorType')?.value || 'n-type';
            const workFunction = safeGetValue('workFunction', 4.5);
            const temperature = safeGetValue('temperature', 300);
            const dopingConc = safeGetValue('dopingConc', 16);
            
            // Physical constants
            const kT = CONSTANTS.k * temperature; // Thermal energy in eV
            const Nd = Math.pow(10, dopingConc);
            
            // Calculate band positions relative to vacuum level
            let metalWorkFunc = workFunction;
            let semiWorkFunc, Ec_bulk, Ev_bulk, Ef_bulk;
            
            if (semiconductorType === 'n-type') {
                // N-type semiconductor
                semiWorkFunc = CONSTANTS.Si_EA + CONSTANTS.Si_Eg/2 + kT * Math.log(CONSTANTS.Nc/Nd);
                Ec_bulk = CONSTANTS.Si_EA; // Conduction band edge
                Ev_bulk = CONSTANTS.Si_EA + CONSTANTS.Si_Eg; // Valence band edge  
                Ef_bulk = Ec_bulk + kT * Math.log(Nd/CONSTANTS.Nc); // Fermi level in bulk
            } else {
                // P-type semiconductor
                semiWorkFunc = CONSTANTS.Si_EA + CONSTANTS.Si_Eg/2 - kT * Math.log(CONSTANTS.Nv/Nd);
                Ec_bulk = CONSTANTS.Si_EA;
                Ev_bulk = CONSTANTS.Si_EA + CONSTANTS.Si_Eg;
                Ef_bulk = Ev_bulk - kT * Math.log(Nd/CONSTANTS.Nv); // Fermi level in bulk
            }
            
            // Built-in potential and band bending
            const Vbi = params.builtInPotential;
            const bandBending = Vbi; // eV
            
            // Convert to pixel coordinates (normalized)
            const energyScale = 30; // pixels per eV
            const baseY = 60; // Base position in %
            const xMetal = 0, xJunction = 30, xSemi = 70, xEnd = 100; // x positions in %
            
            // Calculate y positions for energy levels (lower y = higher energy)
            const metalFermi = baseY;
            const semiFermi = baseY; // Aligned at equilibrium
            
            // Metal bands (flat)
            const metalEc_y = metalFermi - (metalWorkFunc - 0) * energyScale / 4; // Simplified
            
            // Semiconductor bands
            const semiEc_bulk_y = semiFermi - (semiWorkFunc - Ec_bulk) * energyScale / 4;
            const semiEv_bulk_y = semiFermi - (semiWorkFunc - Ev_bulk) * energyScale / 4;
            const semiEc_surface_y = semiEc_bulk_y + bandBending * energyScale / 2;
            const semiEv_surface_y = semiEv_bulk_y + bandBending * energyScale / 2;
            
            // Barrier height visualization
            const barrierStart_y = semiEc_surface_y;
            const barrierHeight_px = params.barrierHeight * energyScale / 2;
            
            return `
                <!-- Energy scale reference -->
                <div style="position: absolute; left: 2%; top: 10%; color: #94a3b8; font-size: 10px; transform: rotate(-90deg);">
                    Energy (eV)
                </div>
                
                <!-- Fermi level (aligned across junction) -->
                <div style="position: absolute; left: 8%; top: ${metalFermi}%; width: 88%; height: 2px; background: #ef4444; z-index: 3; border-top: 2px dashed rgba(255,255,255,0.7);"></div>
                <div style="position: absolute; right: 1%; top: ${metalFermi-1}%; color: #ef4444; font-size: 11px; font-weight: 600;">EF</div>

                <!-- Vacuum level reference line -->
                <div style="position: absolute; left: 8%; top: 15%; width: 88%; height: 1px; background: rgba(255,255,255,0.3); z-index: 1;"></div>
                <div style="position: absolute; right: 1%; top: 14%; color: rgba(255,255,255,0.6); font-size: 9px;">Evac</div>

                <!-- Metal region -->
                <div style="position: absolute; left: 8%; top: 20%; width: 22%; height: 60%; border-right: 2px solid rgba(255,255,255,0.3); background: rgba(99,102,241,0.1);">
                    <div style="position: absolute; top: 10%; left: 50%; transform: translateX(-50%); color: #6366f1; font-size: 10px; font-weight: 600;">Metal</div>
                    <div style="position: absolute; top: 20%; left: 50%; transform: translateX(-50%); color: #60a5fa; font-size: 9px;">φm = ${workFunction.toFixed(1)} eV</div>
                </div>

                <!-- Junction/Depletion region -->
                <div style="position: absolute; left: 30%; top: 20%; width: 40%; height: 60%; background: rgba(245,158,11,0.1); border-left: 2px solid rgba(245,158,11,0.5); border-right: 2px solid rgba(245,158,11,0.5);">
                    <div style="position: absolute; top: 5%; left: 50%; transform: translateX(-50%); color: #f59e0b; font-size: 9px; font-weight: 600;">Depletion</div>
                </div>

                <!-- Semiconductor region -->
                <div style="position: absolute; left: 70%; top: 20%; width: 26%; height: 60%; border-left: 2px solid rgba(255,255,255,0.3); background: rgba(16,185,129,0.1);">
                    <div style="position: absolute; top: 10%; left: 50%; transform: translateX(-50%); color: #10b981; font-size: 10px; font-weight: 600;">${semiconductorType.toUpperCase()}</div>
                    <div style="position: absolute; top: 20%; left: 50%; transform: translateX(-50%); color: #34d399; font-size: 9px;">N = 10¹⁶ cm⁻³</div>
                </div>

                <!-- Energy bands using SVG for precision -->
                <svg width="88%" height="60%" style="position: absolute; left: 8%; top: 20%;" viewBox="0 0 400 240">
                    <defs>
                        <marker id="fieldArrowEq" markerWidth="8" markerHeight="6" refX="8" refY="3" orient="auto">
                            <polygon points="0,0 8,3 0,6" fill="#6366f1"/>
                        </marker>
                    </defs>
                    
                    <!-- Conduction band -->
                    <!-- Metal side (flat) -->
                    <line x1="0" y1="${120 + semiEc_surface_y - metalFermi}" x2="120" y2="${120 + semiEc_surface_y - metalFermi}" 
                          stroke="#10b981" stroke-width="3"/>
                    
                    <!-- Junction bending (smooth curve) -->
                    <path d="M 120 ${120 + semiEc_surface_y - metalFermi} 
                             Q 200 ${120 + semiEc_bulk_y - metalFermi} 
                             280 ${120 + semiEc_bulk_y - metalFermi}" 
                          stroke="#10b981" stroke-width="3" fill="none"/>
                    
                    <!-- Semiconductor bulk (flat) -->
                    <line x1="280" y1="${120 + semiEc_bulk_y - metalFermi}" x2="400" y2="${120 + semiEc_bulk_y - metalFermi}" 
                          stroke="#10b981" stroke-width="3"/>

                    <!-- Valence band (semiconductor only) -->
                    <!-- Junction bending -->
                    <path d="M 120 ${120 + semiEv_surface_y - metalFermi} 
                             Q 200 ${120 + semiEv_bulk_y - metalFermi} 
                             280 ${120 + semiEv_bulk_y - metalFermi}" 
                          stroke="#3b82f6" stroke-width="3" fill="none"/>
                    
                    <!-- Semiconductor bulk -->
                    <line x1="280" y1="${120 + semiEv_bulk_y - metalFermi}" x2="400" y2="${120 + semiEv_bulk_y - metalFermi}" 
                          stroke="#3b82f6" stroke-width="3"/>

                    <!-- Electric field arrows in depletion region -->
                    <line x1="140" y1="80" x2="180" y2="80" stroke="#6366f1" stroke-width="2" marker-end="url(#fieldArrowEq)" opacity="0.8"/>
                    <line x1="140" y1="120" x2="180" y2="120" stroke="#6366f1" stroke-width="2" marker-end="url(#fieldArrowEq)" opacity="0.6"/>
                    <line x1="140" y1="160" x2="180" y2="160" stroke="#6366f1" stroke-width="2" marker-end="url(#fieldArrowEq)" opacity="0.4"/>
                    
                    <!-- Band labels -->
                    <text x="390" y="${120 + semiEc_bulk_y - metalFermi - 5}" fill="#10b981" font-size="12" font-weight="bold">Ec</text>
                    <text x="390" y="${120 + semiEv_bulk_y - metalFermi + 15}" fill="#3b82f6" font-size="12" font-weight="bold">Ev</text>
                </svg>

                <!-- Barrier height indication -->
                <div style="position: absolute; left: 25%; top: ${25 + (semiEc_surface_y - metalFermi)/4}%; color: #f59e0b; font-size: 10px; font-weight: 600; background: rgba(0,0,0,0.7); padding: 2px 6px; border-radius: 4px;">
                    φB = ${params.barrierHeight.toFixed(2)} eV
                </div>

                <!-- Built-in potential indication -->
                <div style="position: absolute; left: 45%; top: 85%; color: #a855f7; font-size: 10px; font-weight: 600; background: rgba(0,0,0,0.7); padding: 2px 6px; border-radius: 4px;">
                    Vbi = ${params.builtInPotential.toFixed(2)} V
                </div>

                <!-- Electric field label -->
                <div style="position: absolute; left: 35%; top: 25%; color: #6366f1; font-size: 10px; font-weight: 600;">
                    <i class="fas fa-bolt"></i> E-field
                </div>
            `;
        }

        // Biasing visualization
        function updateBiasingVisualization() {
            const canvas = safeGetElement('biasingCanvas');
            if (!canvas) return;

            const biasVoltage = safeGetValue('biasVoltage', 0);
            const depletionChangePercent = parseFloat(safeGetElement('depletionChange')?.textContent?.replace('%', '') || '0');
            
            const baseWidth = 15;
            const adjustedWidth = Math.max(5, Math.min(25, baseWidth * (1 + depletionChangePercent / 100)));

            canvas.innerHTML = `
                <div style="position: relative; width: 100%; height: 100%; padding: 20px;">
                    <!-- Voltage source indicator -->
                    <div style="position: absolute; left: 5%; top: 5%; padding: 10px; background: rgba(99, 102, 241, 0.2); border-radius: 8px; border: 1px solid #6366f1;">
                        <div style="color: #6366f1; font-weight: 600;">Applied Voltage</div>
                        <div style="color: #60a5fa; font-size: 1.2em; font-weight: 700;">${biasVoltage.toFixed(1)} V</div>
                    </div>

                    <!-- Bias condition indicator -->
                    <div style="position: absolute; right: 5%; top: 5%; padding: 10px; background: rgba(16, 185, 129, 0.2); border-radius: 8px; border: 1px solid #10b981;">
                        <div style="color: #10b981; font-weight: 600;">${safeGetElement('biasCondition')?.textContent || 'Equilibrium'}</div>
                        <div style="color: #34d399; font-size: 0.9em;">J = ${safeGetElement('currentDensity')?.textContent || '0 A/cm²'}</div>
                    </div>

                    <!-- Junction structure -->
                    <div class="junction-region metal-region" style="left: 5%; top: 25%; width: 25%; height: 40%; color: white; font-weight: 600;">
                        <div>Metal (+)</div>
                        ${biasVoltage > 0 ? generateChargeCarriers('metal', 10) : generateChargeCarriers('metal', 6)}
                    </div>

                    <div class="junction-region depletion-region" style="left: 30%; top: 25%; width: ${adjustedWidth}%; height: 40%; transition: width 0.5s ease; color: white; font-weight: 600;">
                        <div style="font-size: 0.9em;">
                            <div>Depletion</div>
                            <div style="font-size: 0.8em;">${(100 + depletionChangePercent).toFixed(0)}%</div>
                        </div>
                        ${generateElectricField(biasVoltage)}
                    </div>

                    <div class="junction-region semiconductor-region" style="left: ${30 + adjustedWidth}%; top: 25%; width: ${65 - adjustedWidth}%; height: 40%; color: white; font-weight: 600;">
                        <div>Semiconductor (-)</div>
                        ${biasVoltage > 0 ? generateChargeCarriers('semiconductor', 8) : generateChargeCarriers('semiconductor', 4)}
                    </div>

                    <!-- Current flow visualization for forward bias -->
                    ${biasVoltage > 0.1 ? generateCurrentFlow() : ''}

                    <!-- Energy diagram -->
                    <div style="position: absolute; left: 5%; bottom: 5%; width: 90%; height: 25%; background: rgba(255,255,255,0.05); border-radius: 10px; border: 1px solid rgba(255,255,255,0.1); padding: 10px;">
                        <div style="color: #94a3b8; font-weight: 600; margin-bottom: 5px; text-align: center; font-size: 0.9em;">Biased Energy Bands (V = ${biasVoltage.toFixed(1)}V)</div>
                        ${generateBiasedEnergyBands(biasVoltage)}
                    </div>
                </div>
            `;
        }

        // Generate electric field visualization
        function generateElectricField(bias) {
            const fieldStrength = Math.max(0.5, 1 + Math.abs(bias) * 0.5);
            let field = '';
            
            for (let i = 0; i < 3; i++) {
                const y = 25 + i * 25;
                const opacity = Math.min(1, fieldStrength) - i * 0.2;
                const length = 60 + Math.abs(bias) * 10;
                
                field += `
                    <div style="position: absolute; left: 15%; top: ${y}%; width: ${length}%; height: 2px; background: linear-gradient(to right, #6366f1, #8b5cf6); opacity: ${Math.max(0.3, opacity)}; border-radius: 1px;">
                        <div style="position: absolute; right: -5px; top: -2px; width: 0; height: 0; border-left: 6px solid #6366f1; border-top: 3px solid transparent; border-bottom: 3px solid transparent;"></div>
                    </div>
                `;
            }
            
            return field;
        }

        // Generate current flow arrows
        function generateCurrentFlow() {
            return `
                <div style="position: absolute; left: 10%; top: 15%; color: #fbbf24; font-weight: 600; font-size: 0.9em; display: flex; align-items: center; gap: 5px;">
                    <i class="fas fa-arrow-right current-arrow"></i>
                    <span>Current Flow</span>
                </div>
                <div style="position: absolute; left: 15%; top: 20%; width: 70%; height: 3px; background: linear-gradient(to right, #fbbf24, #f59e0b); border-radius: 2px; overflow: hidden;">
                    <div style="position: absolute; top: 0; left: 0; width: 20px; height: 100%; background: linear-gradient(to right, transparent, #fff, transparent); animation: currentFlow 1.5s linear infinite;"></div>
                    <div style="position: absolute; right: -5px; top: -2px; width: 0; height: 0; border-left: 6px solid #f59e0b; border-top: 3px solid transparent; border-bottom: 3px solid transparent;"></div>
                </div>
            `;
        }

        // Generate biased energy bands with proper physics
        function generateBiasedEnergyBands(bias) {
            const params = calculateJunctionParameters();
            const semiconductorType = safeGetElement('semiconductorType')?.value || 'n-type';
            const workFunction = safeGetValue('workFunction', 4.5);
            const temperature = safeGetValue('temperature', 300);
            const dopingConc = safeGetValue('dopingConc', 16);
            
            // Calculate effective built-in potential under bias
            const Vbi = params.builtInPotential;
            const effectiveVbi = Math.max(0.05, Vbi - bias); // Can't go negative
            const effectiveBandBending = effectiveVbi;
            
            // Calculate how bias affects band positions
            const biasEffect = bias; // Applied voltage shifts bands
            const barrierReduction = Math.max(0, bias); // Forward bias reduces barrier
            const effectiveBarrier = Math.max(0.1, params.barrierHeight - barrierReduction);
            
            // Coordinate system
            const baseY = 60; // Reference Fermi level position
            const energyScale = 25; // pixels per eV for visualization
            
            // Calculate band positions
            const kT = CONSTANTS.k * temperature;
            const Nd = Math.pow(10, dopingConc);
            
            let semiEc_bulk_y, semiEv_bulk_y, semiEc_surface_y, semiEv_surface_y;
            
            if (semiconductorType === 'n-type') {
                semiEc_bulk_y = baseY - 15; // Conduction band in bulk
                semiEv_bulk_y = baseY + 15; // Valence band in bulk  
                semiEc_surface_y = semiEc_bulk_y + effectiveBandBending * energyScale / 3;
                semiEv_surface_y = semiEv_bulk_y + effectiveBandBending * energyScale / 3;
            } else {
                semiEc_bulk_y = baseY - 15;
                semiEv_bulk_y = baseY + 15;
                semiEc_surface_y = semiEc_bulk_y - effectiveBandBending * energyScale / 3;
                semiEv_surface_y = semiEv_bulk_y - effectiveBandBending * energyScale / 3;
            }
            
            // Apply bias shift to metal side
            const metalShift = biasEffect * energyScale / 4;
            const metalFermi_y = baseY + metalShift;
            const semiFermi_y = baseY; // Semiconductor Fermi level reference
            
            // Bias condition colors
            const biasColor = bias > 0.1 ? '#10b981' : bias < -0.1 ? '#ef4444' : '#94a3b8';
            const biasLabel = bias > 0.1 ? 'Forward Bias' : bias < -0.1 ? 'Reverse Bias' : 'Equilibrium';
            
            return `
                <!-- Bias condition indicator -->
                <div style="position: absolute; left: 5%; top: 5%; color: ${biasColor}; font-size: 10px; font-weight: 600; background: rgba(0,0,0,0.8); padding: 4px 8px; border-radius: 6px; border: 1px solid ${biasColor};">
                    ${biasLabel} (${bias.toFixed(1)}V)
                </div>
                
                <!-- Energy scale -->
                <div style="position: absolute; left: 2%; top: 15%; color: #94a3b8; font-size: 9px; transform: rotate(-90deg);">Energy</div>
                
                <!-- Fermi levels (split under bias) -->
                <!-- Metal Fermi level -->
                <div style="position: absolute; left: 8%; top: ${metalFermi_y}%; width: 22%; height: 2px; background: #ef4444; z-index: 3;"></div>
                <div style="position: absolute; left: 25%; top: ${metalFermi_y-1}%; color: #ef4444; font-size: 9px; font-weight: 600;">EF,m</div>
                
                <!-- Semiconductor Fermi level -->
                <div style="position: absolute; left: 70%; top: ${semiFermi_y}%; width: 26%; height: 2px; background: #ef4444; z-index: 3;"></div>
                <div style="position: absolute; left: 85%; top: ${semiFermi_y-1}%; color: #ef4444; font-size: 9px; font-weight: 600;">EF,s</div>
                
                <!-- Quasi-Fermi level difference indication -->
                ${Math.abs(bias) > 0.1 ? `
                    <div style="position: absolute; left: 50%; top: ${Math.min(metalFermi_y, semiFermi_y) + Math.abs(metalFermi_y - semiFermi_y)/2}%; color: #fbbf24; font-size: 9px; font-weight: 600; background: rgba(0,0,0,0.7); padding: 2px 4px; border-radius: 3px;">
                        qV = ${Math.abs(bias).toFixed(2)} eV
                    </div>
                ` : ''}

                <!-- Material regions -->
                <div style="position: absolute; left: 8%; top: 20%; width: 22%; height: 60%; border-right: 2px solid rgba(255,255,255,0.3); background: rgba(99,102,241,0.1);">
                    <div style="position: absolute; top: 85%; left: 50%; transform: translateX(-50%); color: #6366f1; font-size: 9px; font-weight: 600;">Metal</div>
                </div>

                <div style="position: absolute; left: 30%; top: 20%; width: 40%; height: 60%; background: rgba(245,158,11,0.15); border-left: 2px solid rgba(245,158,11,0.6); border-right: 2px solid rgba(245,158,11,0.6);">
                    <div style="position: absolute; top: 85%; left: 50%; transform: translateX(-50%); color: #f59e0b; font-size: 9px; font-weight: 600;">
                        Depletion (${(effectiveVbi/Vbi*100).toFixed(0)}%)
                    </div>
                </div>

                <div style="position: absolute; left: 70%; top: 20%; width: 26%; height: 60%; border-left: 2px solid rgba(255,255,255,0.3); background: rgba(16,185,129,0.1);">
                    <div style="position: absolute; top: 85%; left: 50%; transform: translateX(-50%); color: #10b981; font-size: 9px; font-weight: 600;">${semiconductorType.toUpperCase()}</div>
                </div>

                <!-- Energy bands with bias effects -->
                <svg width="88%" height="60%" style="position: absolute; left: 8%; top: 20%;" viewBox="0 0 400 240">
                    <defs>
                        <marker id="fieldArrowBias" markerWidth="8" markerHeight="6" refX="8" refY="3" orient="auto">
                            <polygon points="0,0 8,3 0,6" fill="#6366f1"/>
                        </marker>
                    </defs>
                    
                    <!-- Conduction band -->
                    <!-- Metal side (shifted by bias) -->
                    <line x1="0" y1="${120 + metalShift}" x2="120" y2="${120 + metalShift}" 
                          stroke="#10b981" stroke-width="3"/>
                    
                    <!-- Junction region (bending modified by bias) -->
                    <path d="M 120 ${120 + metalShift} 
                             Q 200 ${120 + (semiEc_surface_y + semiEc_bulk_y)/2 - semiFermi_y} 
                             280 ${120 + semiEc_bulk_y - semiFermi_y}" 
                          stroke="#10b981" stroke-width="3" fill="none"/>
                    
                    <!-- Semiconductor bulk -->
                    <line x1="280" y1="${120 + semiEc_bulk_y - semiFermi_y}" x2="400" y2="${120 + semiEc_bulk_y - semiFermi_y}" 
                          stroke="#10b981" stroke-width="3"/>

                    <!-- Valence band (semiconductor only) -->
                    <!-- Junction region -->
                    <path d="M 120 ${120 + metalShift + 40} 
                             Q 200 ${120 + (semiEv_surface_y + semiEv_bulk_y)/2 - semiFermi_y} 
                             280 ${120 + semiEv_bulk_y - semiFermi_y}" 
                          stroke="#3b82f6" stroke-width="3" fill="none"/>
                    
                    <!-- Semiconductor bulk -->
                    <line x1="280" y1="${120 + semiEv_bulk_y - semiFermi_y}" x2="400" y2="${120 + semiEv_bulk_y - semiFermi_y}" 
                          stroke="#3b82f6" stroke-width="3"/>

                    <!-- Electric field arrows (intensity depends on bias) -->
                    ${effectiveVbi > 0.1 ? `
                        <line x1="140" y1="80" x2="${140 + 30 * effectiveVbi/Vbi}" y2="80" stroke="#6366f1" stroke-width="2" marker-end="url(#fieldArrowBias)" opacity="${0.3 + 0.5 * effectiveVbi/Vbi}"/>
                        <line x1="140" y1="120" x2="${140 + 25 * effectiveVbi/Vbi}" y2="120" stroke="#6366f1" stroke-width="2" marker-end="url(#fieldArrowBias)" opacity="${0.2 + 0.4 * effectiveVbi/Vbi}"/>
                        <line x1="140" y1="160" x2="${140 + 20 * effectiveVbi/Vbi}" y2="160" stroke="#6366f1" stroke-width="2" marker-end="url(#fieldArrowBias)" opacity="${0.1 + 0.3 * effectiveVbi/Vbi}"/>
                    ` : ''}
                    
                    <!-- Band labels -->
                    <text x="390" y="${120 + semiEc_bulk_y - semiFermi_y - 5}" fill="#10b981" font-size="11" font-weight="bold">Ec</text>
                    <text x="390" y="${120 + semiEv_bulk_y - semiFermi_y + 15}" fill="#3b82f6" font-size="11" font-weight="bold">Ev</text>
                    
                    <!-- Effective barrier indication -->
                    ${bias > 0 ? `
                        <text x="160" y="60" fill="#f59e0b" font-size="10" font-weight="bold">φeff = ${effectiveBarrier.toFixed(2)} eV</text>
                        <line x1="140" y1="70" x2="140" y2="${70 + effectiveBarrier * 15}" stroke="#f59e0b" stroke-width="2" opacity="0.8"/>
                    ` : ''}
                </svg>

                <!-- Current flow indication for forward bias -->
                ${bias > 0.1 ? `
                    <div style="position: absolute; left: 15%; top: 10%; color: #fbbf24; font-size: 10px; font-weight: 600; display: flex; align-items: center; gap: 5px;">
                        <i class="fas fa-arrow-right"></i>
                        <span>Electron Flow</span>
                    </div>
                    <div style="position: absolute; left: 35%; top: 15%; width: 30%; height: 2px; background: linear-gradient(to right, #fbbf24, #f59e0b); border-radius: 1px;">
                        <div style="position: absolute; right: -3px; top: -1px; width: 0; height: 0; border-left: 4px solid #f59e0b; border-top: 2px solid transparent; border-bottom: 2px solid transparent;"></div>
                    </div>
                ` : ''}

                <!-- Effective parameters display -->
                <div style="position: absolute; right: 5%; top: 10%; background: rgba(16,23,42,0.9); padding: 8px; border-radius: 6px; border: 1px solid ${biasColor}; font-size: 9px;">
                    <div style="color: ${biasColor}; font-weight: 600; margin-bottom: 3px;">Bias Effects:</div>
                    <div style="color: #cbd5e1;">Barrier: ${effectiveBarrier.toFixed(2)} eV</div>
                    <div style="color: #cbd5e1;">Field: ${(effectiveVbi/Vbi*100).toFixed(0)}%</div>
                    <div style="color: #cbd5e1;">Width: ${((effectiveVbi/Vbi)*100).toFixed(0)}%</div>
                </div>
            `;
        }

        // Applications visualization
        function updateApplicationsVisualization() {
            const canvas = safeGetElement('applicationsCanvas');
            if (!canvas) return;

            // Since we only have rectifier as an option now, always generate rectifier demo
            const content = generateRectifierDemo();

            canvas.innerHTML = content;
            
            // Update the parameters display
            updateApplicationsParameters();

            // Initialize demo components with proper delay
            setTimeout(() => {
                initRectifierDemo();
                // Always automatically start the demo when in applications tab
                if (currentTab === 'applications') {
                    console.log('Auto-starting rectifier animation...');
                    isDemoRunning = true;
                    window.capacitorVoltage = 0;
                    window.prevRectifierType = safeGetElement('rectifierType')?.value || 'half-wave';
                    window.prevCapacitorState = safeGetElement('addCapacitor')?.checked || false;
                    window.prevCapacitance = safeGetValue('capacitance', 470);
                    window.prevLoadResistance = safeGetValue('loadResistance', 100);
                    // Start the animation
                    animateRectifier();
                }
            }, 100);
        }

        // Generate rectifier demonstration
        function generateRectifierDemo() {
            const rectifierType = safeGetElement('rectifierType')?.value || 'half-wave';
            const addCapacitor = safeGetElement('addCapacitor')?.checked || false;

            if (rectifierType === 'half-wave') {
                return generateHalfWaveRectifier(addCapacitor);
            } else {
                return generateFullWaveRectifier(addCapacitor);
            }
        }

        // Generate half-wave rectifier demo
        function generateHalfWaveRectifier(withCapacitor) {
            const inputAmplitude = 12; // Fixed at 12V
            const loadResistance = safeGetValue('loadResistance', 100);
            const capacitance = safeGetValue('capacitance', 470);
            
            return `
                <div style="position: relative; width: 100%; height: 100%; padding: 20px;">
                    <div style="text-align: center; margin-bottom: 20px; color: #60a5fa; font-weight: 600; font-size: 1.2em;">
                        <i class="fas fa-wave-square"></i> Half-Wave Rectifier ${withCapacitor ? 'with Filter Capacitor' : ''}
                    </div>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 30px; height: 85%;">
                        <!-- Circuit diagram -->
                        <div style="background: rgba(255,255,255,0.05); border-radius: 15px; padding: 20px; border: 1px solid rgba(255,255,255,0.1);">
                            <h4 style="color: #94a3b8; margin-bottom: 15px; text-align: center;">Circuit Diagram</h4>
                            
                            <svg width="100%" height="70%" viewBox="0 0 500 250" style="background: rgba(255,255,255,0.02); border-radius: 10px;">
                                <!-- AC Source -->
                                <circle cx="80" cy="125" r="30" fill="none" stroke="#6366f1" stroke-width="3"/>
                                <text x="80" y="130" text-anchor="middle" fill="#6366f1" font-size="14" font-weight="bold">AC</text>
                                <text x="80" y="170" text-anchor="middle" fill="#6366f1" font-size="11">${inputAmplitude}V</text>
                                
                                <!-- Wires -->
                                <line x1="110" y1="125" x2="180" y2="125" stroke="#94a3b8" stroke-width="3"/>
                                <line x1="240" y1="125" x2="${withCapacitor ? '310' : '350'}" y2="125" stroke="#94a3b8" stroke-width="3"/>
                                
                                <!-- Schottky Diode -->
                                <polygon points="190,110 220,125 190,140" fill="#ef4444" stroke="#dc2626" stroke-width="2"/>
                                <line x1="220" y1="110" x2="220" y2="140" stroke="#dc2626" stroke-width="3"/>
                                <text x="205" y="160" text-anchor="middle" fill="#ef4444" font-size="11" font-weight="bold">Schottky</text>
                                
                                ${withCapacitor ? `
                                    <!-- Filter Capacitor -->
                                    <line x1="320" y1="100" x2="320" y2="150" stroke="#a855f7" stroke-width="3"/>
                                    <line x1="330" y1="105" x2="330" y2="145" stroke="#a855f7" stroke-width="3"/>
                                    <text x="325" y="175" text-anchor="middle" fill="#a855f7" font-size="10" font-weight="bold">${capacitance}μF</text>
                                    <line x1="330" y1="125" x2="370" y2="125" stroke="#94a3b8" stroke-width="3"/>
                                ` : ''}
                                
                                <!-- Load Resistor -->
                                <rect x="${withCapacitor ? '360' : '340'}" y="115" width="40" height="20" fill="none" stroke="#10b981" stroke-width="2" rx="3"/>
                                <text x="${withCapacitor ? '380' : '360'}" y="125" text-anchor="middle" fill="#10b981" font-size="10" font-weight="bold">R</text>
                                <text x="${withCapacitor ? '380' : '360'}" y="105" text-anchor="middle" fill="#10b981" font-size="10" font-weight="bold">${loadResistance}Ω</text>
                                
                                <!-- Return path -->
                                <line x1="${withCapacitor ? '380' : '360'}" y1="135" x2="${withCapacitor ? '380' : '360'}" y2="180" stroke="#94a3b8" stroke-width="3"/>
                                <line x1="${withCapacitor ? '380' : '360'}" y1="180" x2="80" y2="180" stroke="#94a3b8" stroke-width="3"/>
                                <line x1="80" y1="180" x2="80" y2="155" stroke="#94a3b8" stroke-width="3"/>
                                
                                ${withCapacitor ? `
                                    <line x1="320" y1="150" x2="320" y2="180" stroke="#94a3b8" stroke-width="3"/>
                                ` : ''}
                                
                                <!-- Voltage labels -->
                                <text x="30" y="115" fill="#6366f1" font-size="12" font-weight="bold">Vin</text>
                                <text x="${withCapacitor ? '420' : '410'}" y="115" fill="#10b981" font-size="12" font-weight="bold">Vout</text>
                            </svg>
                            
                            <div style="margin-top: 15px; font-size: 0.9em;">
                                <div style="color: #94a3b8; font-weight: 600; margin-bottom: 8px;">Key Features:</div>
                                <div style="color: #cbd5e1;">• Low forward voltage drop (0.3V)</div>
                                <div style="color: #cbd5e1;">• Fast switching speed (< 1ns)</div>
                                <div style="color: #cbd5e1;">• High frequency operation</div>
                                <div style="color: #cbd5e1;">• ${withCapacitor ? 'Reduced ripple with filter' : 'Simple, cost-effective design'}</div>
                            </div>
                        </div>
                        
                        <!-- Waveforms -->
                        <div style="background: rgba(255,255,255,0.05); border-radius: 15px; padding: 20px; border: 1px solid rgba(255,255,255,0.1);">
                            <h4 style="color: #94a3b8; margin-bottom: 15px; text-align: center;">Input/Output Waveforms</h4>
                            
                            <div style="margin-bottom: 20px;">
                                <div style="color: #6366f1; margin-bottom: 8px; font-weight: 600; font-size: 0.9em;">Input (AC)</div>
                                <canvas id="inputWave" width="300" height="80" style="width: 100%; background: rgba(255,255,255,0.02); border-radius: 8px;"></canvas>
                            </div>
                            
                            <div style="margin-bottom: 20px;">
                                <div style="color: #10b981; margin-bottom: 8px; font-weight: 600; font-size: 0.9em;">Output ${withCapacitor ? '(Filtered)' : '(Rectified)'}</div>
                                <canvas id="outputWave" width="300" height="80" style="width: 100%; background: rgba(255,255,255,0.02); border-radius: 8px;"></canvas>
                            </div>
                            
                            <div style="margin-bottom: 15px;">
                                <div style="color: #a855f7; margin-bottom: 8px; font-weight: 600; font-size: 0.9em;">Capacitor Voltage ${withCapacitor ? '' : ''}</div>
                                <canvas id="capacitorWave" width="300" height="60" style="width: 100%; background: rgba(255,255,255,0.02); border-radius: 8px;"></canvas>
                            </div>
                            
                            <div style="font-size: 0.9em;">
                                <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                                    <span style="color: #94a3b8;">Frequency:</span>
                                    <span style="color: #60a5fa; font-weight: 600;" id="rectifierFreq">60 Hz</span>
                                </div>
                                <div style="display: flex; justify-content: space-between;">
                                    <span style="color: #94a3b8;">Conduction Angle:</span>
                                    <span style="color: #60a5fa; font-weight: 600;">180°</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        // Generate full-wave bridge rectifier demo
        function generateFullWaveRectifier(withCapacitor) {
            const inputAmplitude = 12; // Fixed at 12V
            const loadResistance = safeGetValue('loadResistance', 100);
            const capacitance = safeGetValue('capacitance', 470);
            
            return `
                <div style="position: relative; width: 100%; height: 100%; padding: 20px;">
                    <div style="text-align: center; margin-bottom: 20px; color: #60a5fa; font-weight: 600; font-size: 1.2em;">
                        <i class="fas fa-wave-square"></i> Full-Wave Bridge Rectifier ${withCapacitor ? 'with Filter Capacitor' : ''}
                    </div>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 30px; height: 85%;">
                        <!-- Circuit diagram -->
                        <div style="background: rgba(255,255,255,0.05); border-radius: 15px; padding: 20px; border: 1px solid rgba(255,255,255,0.1);">
                            <h4 style="color: #94a3b8; margin-bottom: 15px; text-align: center;">Bridge Circuit Diagram</h4>
                            
                            <svg width="100%" height="70%" viewBox="0 0 520 300" style="background: rgba(255,255,255,0.02); border-radius: 10px;">
                                <!-- AC Source -->
                                <circle cx="80" cy="150" r="25" fill="none" stroke="#6366f1" stroke-width="3"/>
                                <text x="80" y="155" text-anchor="middle" fill="#6366f1" font-size="12" font-weight="bold">AC</text>
                                <text x="80" y="185" text-anchor="middle" fill="#6366f1" font-size="10">${inputAmplitude}V</text>
                                
                                <!-- Bridge diodes in proper diamond configuration -->
                                <!-- D1 (top) -->
                                <polygon points="210,80 235,95 210,110" fill="#ef4444" stroke="#dc2626" stroke-width="2"/>
                                <line x1="235" y1="80" x2="235" y2="110" stroke="#dc2626" stroke-width="2"/>
                                <text x="222" y="70" text-anchor="middle" fill="#ef4444" font-size="10" font-weight="bold">D1</text>
                                
                                <!-- D2 (right) -->
                                <polygon points="280,125 305,140 280,155" fill="#ef4444" stroke="#dc2626" stroke-width="2"/>
                                <line x1="305" y1="125" x2="305" y2="155" stroke="#dc2626" stroke-width="2"/>
                                <text x="315" y="145" text-anchor="middle" fill="#ef4444" font-size="10" font-weight="bold">D2</text>
                                
                                <!-- D3 (bottom) -->
                                <polygon points="235,190 210,205 235,220" fill="#ef4444" stroke="#dc2626" stroke-width="2"/>
                                <line x1="210" y1="190" x2="210" y2="220" stroke="#dc2626" stroke-width="2"/>
                                <text x="222" y="240" text-anchor="middle" fill="#ef4444" font-size="10" font-weight="bold">D3</text>
                                
                                <!-- D4 (left) -->
                                <polygon points="140,155 165,140 140,125" fill="#ef4444" stroke="#dc2626" stroke-width="2"/>
                                <line x1="165" y1="125" x2="165" y2="155" stroke="#dc2626" stroke-width="2"/>
                                <text x="125" y="145" text-anchor="middle" fill="#ef4444" font-size="10" font-weight="bold">D4</text>
                                
                                <!-- AC source connections to bridge -->
                                <line x1="80" y1="125" x2="80" y2="95" stroke="#94a3b8" stroke-width="3"/>
                                <line x1="80" y1="95" x2="165" y2="95" stroke="#94a3b8" stroke-width="3"/>
                                <line x1="165" y1="95" x2="210" y2="95" stroke="#94a3b8" stroke-width="3"/>
                                
                                <line x1="80" y1="175" x2="80" y2="205" stroke="#94a3b8" stroke-width="3"/>
                                <line x1="80" y1="205" x2="210" y2="205" stroke="#94a3b8" stroke-width="3"/>
                                
                                <!-- Bridge internal connections -->
                                <line x1="235" y1="95" x2="280" y2="140" stroke="#94a3b8" stroke-width="2"/>
                                <line x1="305" y1="140" x2="280" y2="155" stroke="#94a3b8" stroke-width="2"/>
                                <line x1="280" y1="155" x2="235" y2="205" stroke="#94a3b8" stroke-width="2"/>
                                <line x1="210" y1="205" x2="165" y2="155" stroke="#94a3b8" stroke-width="2"/>
                                <line x1="140" y1="140" x2="165" y2="125" stroke="#94a3b8" stroke-width="2"/>
                                <line x1="165" y1="125" x2="210" y2="95" stroke="#94a3b8" stroke-width="2"/>
                                
                                <!-- Positive output connection -->
                                <line x1="235" y1="80" x2="235" y2="60" stroke="#94a3b8" stroke-width="3"/>
                                <line x1="235" y1="60" x2="${withCapacitor ? '340' : '370'}" y2="60" stroke="#94a3b8" stroke-width="3"/>
                                
                                ${withCapacitor ? `
                                    <!-- Filter Capacitor -->
                                    <line x1="350" y1="45" x2="350" y2="95" stroke="#a855f7" stroke-width="3"/>
                                    <line x1="360" y1="50" x2="360" y2="90" stroke="#a855f7" stroke-width="3"/>
                                    <text x="355" y="115" text-anchor="middle" fill="#a855f7" font-size="10" font-weight="bold">${capacitance}μF</text>
                                    <line x1="360" y1="60" x2="390" y2="60" stroke="#94a3b8" stroke-width="3"/>
                                ` : ''}
                                
                                <!-- Load Resistor -->
                                <rect x="${withCapacitor ? '380' : '360'}" y="50" width="40" height="20" fill="none" stroke="#10b981" stroke-width="2" rx="3"/>
                                <text x="${withCapacitor ? '400' : '380'}" y="60" text-anchor="middle" fill="#10b981" font-size="10" font-weight="bold">R</text>
                                <text x="${withCapacitor ? '400' : '380'}" y="40" text-anchor="middle" fill="#10b981" font-size="10">${loadResistance}Ω</text>
                                
                                <!-- Negative output connection -->
                                <line x1="${withCapacitor ? '400' : '380'}" y1="70" x2="${withCapacitor ? '400' : '380'}" y2="240" stroke="#94a3b8" stroke-width="3"/>
                                <line x1="${withCapacitor ? '400' : '380'}" y1="240" x2="210" y2="240" stroke="#94a3b8" stroke-width="3"/>
                                <line x1="210" y1="240" x2="210" y2="220" stroke="#94a3b8" stroke-width="3"/>
                                
                                ${withCapacitor ? `
                                    <line x1="350" y1="95" x2="350" y2="240" stroke="#94a3b8" stroke-width="3"/>
                                ` : ''}
                                
                                <!-- Voltage labels -->
                                <text x="30" y="115" fill="#6366f1" font-size="12" font-weight="bold">Vin</text>
                                <text x="${withCapacitor ? '440' : '430'}" y="55" fill="#10b981" font-size="12" font-weight="bold">Vout+</text>
                                <text x="${withCapacitor ? '440' : '430'}" y="250" fill="#10b981" font-size="12" font-weight="bold">Vout-</text>
                                
                                <!-- Current flow indicators -->
                                <text x="260" y="25" fill="#f59e0b" font-size="10" font-weight="bold">Positive Half-Cycle: D1→Load→D2</text>
                                <text x="260" y="280" fill="#f59e0b" font-size="10" font-weight="bold">Negative Half-Cycle: D4→Load→D3</text>
                            </svg>
                            
                            <div style="margin-top: 15px; font-size: 0.9em;">
                                <div style="color: #94a3b8; font-weight: 600; margin-bottom: 8px;">Bridge Advantages:</div>
                                <div style="color: #cbd5e1;">• Both half-cycles utilized</div>
                                <div style="color: #cbd5e1;">• Better transformer utilization</div>
                                <div style="color: #cbd5e1;">• Lower ripple factor (48% vs 121%)</div>
                                <div style="color: #cbd5e1;">• ${withCapacitor ? 'Excellent filtering with capacitor' : 'Higher efficiency (81%)'}</div>
                            </div>
                        </div>
                        
                        <!-- Waveforms -->
                        <div style="background: rgba(255,255,255,0.05); border-radius: 15px; padding: 20px; border: 1px solid rgba(255,255,255,0.1);">
                            <h4 style="color: #94a3b8; margin-bottom: 15px; text-align: center;">Input/Output Waveforms</h4>
                            
                            <div style="margin-bottom: 20px;">
                                <div style="color: #6366f1; margin-bottom: 8px; font-weight: 600; font-size: 0.9em;">Input (AC)</div>
                                <canvas id="inputWave" width="300" height="80" style="width: 100%; background: rgba(255,255,255,0.02); border-radius: 8px;"></canvas>
                            </div>
                            
                            <div style="margin-bottom: 20px;">
                                <div style="color: #10b981; margin-bottom: 8px; font-weight: 600; font-size: 0.9em;">Output ${withCapacitor ? '(Filtered)' : '(Full-Wave)'}</div>
                                <canvas id="outputWave" width="300" height="80" style="width: 100%; background: rgba(255,255,255,0.02); border-radius: 8px;"></canvas>
                            </div>
                            
                            <div style="margin-bottom: 15px;">
                                <div style="color: #a855f7; margin-bottom: 8px; font-weight: 600; font-size: 0.9em;">Capacitor Voltage ${withCapacitor ? '' : '(Disabled)'}</div>
                                <canvas id="capacitorWave" width="300" height="60" style="width: 100%; background: rgba(255,255,255,0.02); border-radius: 8px;"></canvas>
                            </div>
                            
                            <div style="font-size: 0.9em;">
                                <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                                    <span style="color: #94a3b8;">Frequency:</span>
                                    <span style="color: #60a5fa; font-weight: 600;" id="rectifierFreq">60 Hz</span>
                                </div>
                                <div style="display: flex; justify-content: space-between;">
                                    <span style="color: #94a3b8;">Conduction Angle:</span>
                                    <span style="color: #60a5fa; font-weight: 600;">360° (continuous)</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        // Initialize demo functions
        function initRectifierDemo() {
            console.log('Initializing rectifier demo...');
            
            // Update frequency display
            const freq = safeGetValue('signalFreq', 60);
            safeSetValue('rectifierFreq', freq + ' Hz');
            
            // Set initial capacitor slider state
            const addCapacitor = safeGetElement('addCapacitor');
            const capacitanceSlider = safeGetElement('capacitance');
            if (addCapacitor && capacitanceSlider) {
                capacitanceSlider.disabled = !addCapacitor.checked;
            }
            
            // Update initial parameters
            updateApplicationsParameters();
        }

        // stopDemo function removed - simulation now runs continuously

        // Animation functions
        function animateFormation() {
            console.log('Starting formation animation...');
            const canvas = safeGetElement('equilibriumCanvas');
            if (!canvas) return;

            let step = 0;
            const maxSteps = 60;

            function animate() {
                step++;
                const progress = step / maxSteps;

                // Add visual formation effects
                const regions = canvas.querySelectorAll('.junction-region');
                regions.forEach((region, index) => {
                    region.style.opacity = Math.min(1, progress * 2 - index * 0.3);
                    region.style.transform = `translateY(${(1 - progress) * 15}px)`;
                });

                if (progress < 1) {
                    requestAnimationFrame(animate);
                }
            }

            animate();
        }

        function sweepVoltage() {
            if (sweepRunning) return;
            
            console.log('Starting voltage sweep...');
            sweepRunning = true;
            const biasSlider = safeGetElement('biasVoltage');
            if (!biasSlider) return;

            let voltage = -2;
            const step = 0.05;

            function sweep() {
                if (!sweepRunning) return;

                voltage += step;
                if (voltage > 2) {
                    voltage = -2;
                }

                biasSlider.value = voltage;
                updateBiasingParameters();
                if (currentTab === 'biasing') {
                    updateBiasingVisualization();
                }

                setTimeout(sweep, 50);
            }

            sweep();
        }

        function stopSweep() {
            console.log('Stopping voltage sweep...');
            sweepRunning = false;
        }

        function resetDemo() {
            console.log('Resetting demo...');
            isDemoRunning = false;
            
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            
            // Reset capacitor voltage
            window.capacitorVoltage = 0;
            
            // Clear all canvas elements
            const inputCanvas = safeGetElement('inputWave');
            const outputCanvas = safeGetElement('outputWave');
            const capacitorCanvas = safeGetElement('capacitorWave');
            
            if (inputCanvas) {
                const ctx = inputCanvas.getContext('2d');
                ctx.clearRect(0, 0, inputCanvas.width, inputCanvas.height);
            }
            if (outputCanvas) {
                const ctx = outputCanvas.getContext('2d');
                ctx.clearRect(0, 0, outputCanvas.width, outputCanvas.height);
            }
            if (capacitorCanvas) {
                const ctx = capacitorCanvas.getContext('2d');
                ctx.clearRect(0, 0, capacitorCanvas.width, capacitorCanvas.height);
            }
            
            // Reset button state
            const startButton = document.querySelector('button[onclick="startDemo()"]');
            if (startButton) {
                startButton.innerHTML = '<i class="fas fa-play"></i> Start Simulation';
                startButton.disabled = false;
                startButton.style.opacity = '1';
            }
        }

        function startDemo() {
            if (isDemoRunning) {
                console.log('Demo already running');
                return;
            }
            
            const applicationType = safeGetElement('applicationType')?.value || 'rectifier';
            if (applicationType !== 'rectifier') return;
            
            console.log('Starting rectifier demo...');
            isDemoRunning = true;
            
            // Update button to show simulation is running
            const startButton = document.querySelector('button[onclick="startDemo()"]');
            if (startButton) {
                startButton.innerHTML = '<i class="fas fa-cog fa-spin"></i> Simulation Running';
                startButton.disabled = true;
                startButton.style.opacity = '0.7';
            }
            
            // Reset capacitor voltage when starting demo
            window.capacitorVoltage = 0;
            window.prevRectifierType = safeGetElement('rectifierType')?.value || 'half-wave';
            window.prevCapacitorState = safeGetElement('addCapacitor')?.checked || false;
            window.prevCapacitance = safeGetValue('capacitance', 470);
            window.prevLoadResistance = safeGetValue('loadResistance', 100);
            
            animateRectifier();
        }

        // Add this function to detect changes in rectifier parameters
        function shouldResetCapacitor() {
            const currentRectifierType = safeGetElement('rectifierType')?.value || 'half-wave';
            const currentAddCapacitor = safeGetElement('addCapacitor')?.checked || false;
            const currentCapacitance = safeGetValue('capacitance', 470);
            const currentLoadResistance = safeGetValue('loadResistance', 100);
            
            return (
                currentRectifierType !== window.prevRectifierType ||
                currentAddCapacitor !== window.prevCapacitorState ||
                currentCapacitance !== window.prevCapacitance ||
                currentLoadResistance !== window.prevLoadResistance
            );
        }

        function animateRectifier() {
            const inputCanvas = safeGetElement('inputWave');
            const outputCanvas = safeGetElement('outputWave');
            const capacitorCanvas = safeGetElement('capacitorWave');
            
            if (!inputCanvas || !outputCanvas) {
                // If canvas elements are not ready, try again after a short delay
                if (isDemoRunning) {
                    setTimeout(animateRectifier, 100);
                }
                return;
            }

            // Clear any existing animation
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }

            const inputCtx = inputCanvas.getContext('2d');
            const outputCtx = outputCanvas.getContext('2d');
            const capacitorCtx = capacitorCanvas ? capacitorCanvas.getContext('2d') : null;
            
            // Global capacitor voltage state (persistent across frames)
            if (typeof window.capacitorVoltage === 'undefined') {
                window.capacitorVoltage = 0;
            }

            // Track previous rectifier type and capacitor state to reset capacitor when they change
            if (typeof window.prevRectifierType === 'undefined') {
                window.prevRectifierType = '';
            }
            if (typeof window.prevCapacitorState === 'undefined') {
                window.prevCapacitorState = false;
            }
            if (typeof window.prevCapacitance === 'undefined') {
                window.prevCapacitance = 470;
            }
            if (typeof window.prevLoadResistance === 'undefined') {
                window.prevLoadResistance = 100;
            }

            function drawWaves() {
                if (!isDemoRunning) return;

                // Read current parameters on each frame for real-time response
                const frequency = safeGetValue('signalFreq', 60);
                const inputAmplitude = 12; // Fixed at 12V
                const rectifierType = safeGetElement('rectifierType')?.value || 'half-wave';
                const addCapacitor = safeGetElement('addCapacitor')?.checked || false;
                const loadResistance = safeGetValue('loadResistance', 100);
                const capacitance = safeGetValue('capacitance', 470);

                // Reset capacitor if parameters changed
                if (shouldResetCapacitor()) {
                    window.capacitorVoltage = 0;
                    window.prevRectifierType = rectifierType;
                    window.prevCapacitorState = addCapacitor;
                    window.prevCapacitance = capacitance;
                    window.prevLoadResistance = loadResistance;
                }

                // Calculate RC time constant if capacitor is used
                const RC = addCapacitor ? loadResistance * capacitance * 1e-6 : 0;
                const Vf = 0.3; // Forward voltage drop

                const width = inputCanvas.width;
                const height = inputCanvas.height;
                const centerY = height / 2;
                const amplitude = height * 0.25; // Reduced from 0.35 to 0.25 for better visibility

                // Clear all canvases
                inputCtx.clearRect(0, 0, width, height);
                outputCtx.clearRect(0, 0, width, height);
                if (capacitorCtx) {
                    capacitorCtx.clearRect(0, 0, capacitorCanvas.width, capacitorCanvas.height);
                }

                // Draw grid lines
                [inputCtx, outputCtx, capacitorCtx].forEach(ctx => {
                    if (!ctx) return;
                    ctx.strokeStyle = 'rgba(148, 163, 184, 0.1)';
                    ctx.lineWidth = 1;
                    const canvasHeight = ctx.canvas.height;
                    const canvasWidth = ctx.canvas.width;
                    
                    // Horizontal grid lines
                    for (let i = 0; i <= 4; i++) {
                        const y = i * canvasHeight / 4;
                        ctx.beginPath();
                        ctx.moveTo(0, y);
                        ctx.lineTo(canvasWidth, y);
                        ctx.stroke();
                    }
                    
                    // Vertical grid lines
                    for (let i = 0; i <= 8; i++) {
                        const x = i * canvasWidth / 8;
                        ctx.beginPath();
                        ctx.moveTo(x, 0);
                        ctx.lineTo(x, canvasHeight);
                        ctx.stroke();
                    }
                });

                // Draw input sine wave
                inputCtx.strokeStyle = '#6366f1';
                inputCtx.lineWidth = 3;
                inputCtx.beginPath();

                for (let x = 0; x < width; x++) {
                    const t = (x / width) * 4 * Math.PI + time;
                    const y = centerY + amplitude * Math.sin(t * frequency / 60);
                    
                    if (x === 0) {
                        inputCtx.moveTo(x, y);
                    } else {
                        inputCtx.lineTo(x, y);
                    }
                }
                inputCtx.stroke();

                // Draw zero line for input
                inputCtx.strokeStyle = 'rgba(148, 163, 184, 0.3)';
                inputCtx.lineWidth = 1;
                inputCtx.beginPath();
                inputCtx.moveTo(0, centerY);
                inputCtx.lineTo(width, centerY);
                inputCtx.stroke();

                // Calculate current rectified signal for capacitor simulation
                const currentTime = time;
                const inputSignal = Math.sin(currentTime * frequency / 60);
                let currentRectifiedSignal = 0;
                
                if (rectifierType === 'half-wave') {
                    // Half-wave rectification
                    currentRectifiedSignal = Math.max(0, inputSignal * inputAmplitude - Vf);
                } else {
                    // Full-wave rectification
                    currentRectifiedSignal = Math.max(0, Math.abs(inputSignal) * inputAmplitude - 2*Vf);
                }

                // Update capacitor voltage based on current signal
                if (addCapacitor && RC > 0) {
                    const dt = 0.015 * frequency / 60; // Adjust time step based on frequency
                    
                    if (currentRectifiedSignal > window.capacitorVoltage) {
                        // Capacitor charging (diode conducts) - fast charging
                        window.capacitorVoltage = currentRectifiedSignal;
                    } else {
                        // Capacitor discharging through load - exponential decay
                        window.capacitorVoltage *= Math.exp(-dt / RC);
                    }
                }

                // Draw rectified output
                outputCtx.strokeStyle = '#10b981';
                outputCtx.lineWidth = 3;
                outputCtx.beginPath();

                let firstPoint = true;
                for (let x = 0; x < width; x++) {
                    const t = (x / width) * 4 * Math.PI + time;
                    const inputSignal = Math.sin(t * frequency / 60);
                    let outputSignal = 0;
                    
                    if (rectifierType === 'half-wave') {
                        // Half-wave rectification
                        outputSignal = Math.max(0, inputSignal * inputAmplitude - Vf) / inputAmplitude;
                    } else {
                        // Full-wave rectification
                        outputSignal = (Math.abs(inputSignal) * inputAmplitude - 2*Vf) / inputAmplitude;
                        outputSignal = Math.max(0, outputSignal);
                    }

                    // Apply capacitor filtering if enabled
                    if (addCapacitor && RC > 0) {
                        // Use the current capacitor voltage for the waveform display
                        outputSignal = window.capacitorVoltage / inputAmplitude;
                    }
                    
                    const y = centerY - amplitude * outputSignal;
                    
                    if (firstPoint) {
                        outputCtx.moveTo(x, y);
                        firstPoint = false;
                    } else {
                        outputCtx.lineTo(x, y);
                    }
                }
                outputCtx.stroke();

                // Draw zero line for output
                outputCtx.strokeStyle = 'rgba(148, 163, 184, 0.3)';
                outputCtx.lineWidth = 1;
                outputCtx.beginPath();
                outputCtx.moveTo(0, centerY);
                outputCtx.lineTo(width, centerY);
                outputCtx.stroke();

                // Draw capacitor voltage (always shown)
                if (capacitorCtx) {
                    const capHeight = capacitorCanvas.height;
                    const capCenterY = capHeight / 2;
                    const capAmplitude = capHeight * 0.25; // Reduced from 0.35 to 0.25 for better visibility
                    
                    capacitorCtx.strokeStyle = addCapacitor ? '#a855f7' : 'rgba(168, 85, 247, 0.3)'; // Dimmed when disabled
                    capacitorCtx.lineWidth = 2;
                    capacitorCtx.beginPath();
                    
                    firstPoint = true;
                    let tempCapVoltage = 0;
                    
                    if (addCapacitor) {
                        // Draw actual capacitor voltage when enabled
                        for (let x = 0; x < width; x++) {
                            const t = (x / width) * 4 * Math.PI + time;
                            const inputSignal = Math.sin(t * frequency / 60);
                            let rectifiedSignal = 0;
                            
                            if (rectifierType === 'half-wave') {
                                rectifiedSignal = Math.max(0, inputSignal * inputAmplitude - Vf);
                            } else {
                                rectifiedSignal = Math.max(0, Math.abs(inputSignal) * inputAmplitude - 2*Vf);
                            }
                            
                            const dt = 1 / (width * frequency / 4);
                            if (rectifiedSignal > tempCapVoltage) {
                                tempCapVoltage = rectifiedSignal;
                            } else {
                                tempCapVoltage *= Math.exp(-dt / RC);
                            }
                            
                            const y = capCenterY - capAmplitude * (tempCapVoltage / inputAmplitude);
                            
                            if (firstPoint) {
                                capacitorCtx.moveTo(x, y);
                                firstPoint = false;
                            } else {
                                capacitorCtx.lineTo(x, y);
                            }
                        }
                    } else {
                        // Draw flat line at 0V when capacitor is disabled
                        capacitorCtx.moveTo(0, capCenterY);
                        capacitorCtx.lineTo(width, capCenterY);
                    }
                    capacitorCtx.stroke();
                    
                    // Zero line for capacitor
                    capacitorCtx.strokeStyle = 'rgba(148, 163, 184, 0.3)';
                    capacitorCtx.lineWidth = 1;
                    capacitorCtx.beginPath();
                    capacitorCtx.moveTo(0, capCenterY);
                    capacitorCtx.lineTo(width, capCenterY);
                    capacitorCtx.stroke();
                }

                time += 0.015 * (frequency / 60); // Adjust animation speed based on frequency
                animationId = requestAnimationFrame(drawWaves);
            }

            drawWaves();
        }

        // Generate detector demonstration
        

        // Generate mixer demonstration


        // ===========================
        // GUIDED TOUR FUNCTIONS
        // ===========================

        function startGuidedTour() {
            // Check if walkthrough is disabled on mobile
            if (typeof mobileDetection !== 'undefined' && mobileDetection.isWalkthroughDisabled()) {
                alert('The guided walkthrough is disabled on mobile devices for optimal performance. Please use a desktop computer to access the full interactive tour experience.');
                return;
            }
            
            console.log('Starting guided tour...');
            tourActive = true;
            currentTourStep = 0;
            tourScore = 0;
            challengesSolvedInTour = 0;
            hintsUsedInTour = 0;
            
            // Ensure we're on the equilibrium tab
            if (currentTab !== 'equilibrium') {
                switchTab('equilibrium');
            }
            
            document.getElementById('tourOverlay').classList.add('active');
            document.getElementById('tourScore').classList.add('active');
            
            showTourStep();
        }

        function showTourStep() {
            if (currentTourStep >= tourSteps.length) {
                finalizeTour();
                return;
            }
            
            const step = tourSteps[currentTourStep];
            console.log(`Showing tour step ${currentTourStep}: ${step.title}`);
            
            // Update tour popup content
            document.getElementById('tourStepNumber').textContent = `${currentTourStep + 1}/${tourSteps.length}`;
            document.getElementById('tourTitle').textContent = step.title;
            document.getElementById('tourContent').textContent = step.content;
            document.getElementById('tourProgressBar').style.width = `${((currentTourStep + 1) / tourSteps.length) * 100}%`;
            
            // Handle challenge content
            const challengeDiv = document.getElementById('tourChallenge');
            const hintBtn = document.getElementById('tourHintBtn');
            
            if (step.challenge) {
                challengeDiv.style.display = 'block';
                hintBtn.style.display = 'inline-block';
                document.getElementById('tourChallengeContent').textContent = step.challenge.instruction;
                startChallengeMonitoring(step.challenge);
            } else {
                challengeDiv.style.display = 'none';
                hintBtn.style.display = 'none';
            }
            
            // Position tour elements
            positionTourElements(step);
            
            // Show tour popup
            document.getElementById('tourPopup').classList.add('active');
            
            // Update navigation buttons
            document.getElementById('tourPrevBtn').disabled = currentTourStep === 0;
            
            if (currentTourStep === tourSteps.length - 1) {
                document.getElementById('tourNextBtn').textContent = 'Complete Tour';
            } else {
                document.getElementById('tourNextBtn').textContent = step.challenge ? 'Skip Challenge' : 'Next';
            }
            
            updateTourScore();
        }

        function positionTourElements(step) {
            const targetElement = document.querySelector(step.target);
            const spotlight = document.getElementById('tourSpotlight');
            const popup = document.getElementById('tourPopup');
            const secondarySpotlight = document.getElementById('tourSpotlightSecondary');
            
            if (!targetElement) {
                console.warn('Target element not found:', step.target);
                return;
            }
            
            // Clean up previous highlights
            cleanupTourHighlights();
            
            const rect = targetElement.getBoundingClientRect();
            const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
            const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
            
            // Position spotlight
            spotlight.style.left = (rect.left + scrollLeft - 10) + 'px';
            spotlight.style.top = (rect.top + scrollTop - 10) + 'px';
            spotlight.style.width = (rect.width + 20) + 'px';
            spotlight.style.height = (rect.height + 20) + 'px';
            
            // Position secondary spotlight if needed
            if (step.challenge && step.challenge.secondary_highlight) {
                const secondaryElement = document.querySelector(step.challenge.secondary_highlight);
                if (secondaryElement) {
                    const secondaryRect = secondaryElement.getBoundingClientRect();
                    secondarySpotlight.style.left = (secondaryRect.left + scrollLeft - 5) + 'px';
                    secondarySpotlight.style.top = (secondaryRect.top + scrollTop - 5) + 'px';
                    secondarySpotlight.style.width = (secondaryRect.width + 10) + 'px';
                    secondarySpotlight.style.height = (secondaryRect.height + 10) + 'px';
                    secondarySpotlight.style.display = 'block';
                } else {
                    secondarySpotlight.style.display = 'none';
                }
            } else {
                secondarySpotlight.style.display = 'none';
            }
            
            // Get popup dimensions (approximate)
            const popupWidth = 380;
            const popupHeight = 300;
            const margin = 20;
            
            // Calculate available space in each direction
            const spaceRight = window.innerWidth - rect.right;
            const spaceLeft = rect.left;
            const spaceTop = rect.top;
            const spaceBottom = window.innerHeight - rect.bottom;
            
            let popupLeft, popupTop;
            let preferredPosition = step.position;
            
            // Smart positioning based on available space and avoiding content overlap
            switch (preferredPosition) {
                case 'center':
                    popupLeft = (window.innerWidth - popupWidth) / 2;
                    popupTop = (window.innerHeight - popupHeight) / 2;
                    break;
                    
                case 'right':
                    if (spaceRight >= popupWidth + margin) {
                        popupLeft = rect.right + scrollLeft + margin;
                        popupTop = Math.max(margin, rect.top + scrollTop - popupHeight / 2);
                    } else if (spaceLeft >= popupWidth + margin) {
                        // Fallback to left
                        popupLeft = rect.left + scrollLeft - popupWidth - margin;
                        popupTop = Math.max(margin, rect.top + scrollTop - popupHeight / 2);
                    } else {
                        // Fallback to bottom
                        popupLeft = Math.max(margin, Math.min(rect.left + scrollLeft, window.innerWidth - popupWidth - margin));
                        popupTop = rect.bottom + scrollTop + margin;
                    }
                    break;
                    
                case 'left':
                    if (spaceLeft >= popupWidth + margin) {
                        popupLeft = rect.left + scrollLeft - popupWidth - margin;
                        popupTop = Math.max(margin, rect.top + scrollTop - popupHeight / 2);
                    } else if (spaceRight >= popupWidth + margin) {
                        // Fallback to right
                        popupLeft = rect.right + scrollLeft + margin;
                        popupTop = Math.max(margin, rect.top + scrollTop - popupHeight / 2);
                    } else {
                        // Fallback to bottom
                        popupLeft = Math.max(margin, Math.min(rect.left + scrollLeft, window.innerWidth - popupWidth - margin));
                        popupTop = rect.bottom + scrollTop + margin;
                    }
                    break;
                    
                case 'top':
                    if (spaceTop >= popupHeight + margin) {
                        popupLeft = Math.max(margin, Math.min(rect.left + scrollLeft, window.innerWidth - popupWidth - margin));
                        popupTop = rect.top + scrollTop - popupHeight - margin;
                    } else {
                        // Fallback to bottom
                        popupLeft = Math.max(margin, Math.min(rect.left + scrollLeft, window.innerWidth - popupWidth - margin));
                        popupTop = rect.bottom + scrollTop + margin;
                    }
                    break;
                    
                case 'bottom':
                default:
                    if (spaceBottom >= popupHeight + margin) {
                        popupLeft = Math.max(margin, Math.min(rect.left + scrollLeft, window.innerWidth - popupWidth - margin));
                        popupTop = rect.bottom + scrollTop + margin;
                    } else if (spaceTop >= popupHeight + margin) {
                        // Fallback to top
                        popupLeft = Math.max(margin, Math.min(rect.left + scrollLeft, window.innerWidth - popupWidth - margin));
                        popupTop = rect.top + scrollTop - popupHeight - margin;
                    } else {
                        // Fallback to side with most space
                        if (spaceRight >= spaceLeft && spaceRight >= popupWidth + margin) {
                            popupLeft = rect.right + scrollLeft + margin;
                            popupTop = Math.max(margin, rect.top + scrollTop - popupHeight / 2);
                        } else if (spaceLeft >= popupWidth + margin) {
                            popupLeft = rect.left + scrollLeft - popupWidth - margin;
                            popupTop = Math.max(margin, rect.top + scrollTop - popupHeight / 2);
                        } else {
                            // Last resort: center on screen
                            popupLeft = (window.innerWidth - popupWidth) / 2;
                            popupTop = (window.innerHeight - popupHeight) / 2;
                        }
                    }
                    break;
            }
            
            // Ensure popup stays within screen bounds
            popupLeft = Math.max(margin, Math.min(popupLeft, window.innerWidth - popupWidth - margin));
            popupTop = Math.max(margin, Math.min(popupTop, window.innerHeight - popupHeight - margin));
            
            // Additional check to avoid covering the target element completely
            const targetCenterX = rect.left + rect.width / 2;
            const targetCenterY = rect.top + rect.height / 2;
            const popupCenterX = popupLeft + popupWidth / 2;
            const popupCenterY = popupTop + popupHeight / 2;
            
            // If popup would cover target, try to reposition
            if (Math.abs(targetCenterX - popupCenterX) < (rect.width + popupWidth) / 2 && 
                Math.abs(targetCenterY - popupCenterY) < (rect.height + popupHeight) / 2) {
                
                // Try to position on the side with most space
                if (spaceRight >= spaceLeft) {
                    popupLeft = Math.min(rect.right + scrollLeft + margin, window.innerWidth - popupWidth - margin);
                } else {
                    popupLeft = Math.max(rect.left + scrollLeft - popupWidth - margin, margin);
                }
            }
            
            popup.style.left = popupLeft + 'px';
            popup.style.top = popupTop + 'px';
            
            // Auto-scroll disabled - keeping everything on a single page view
            // The tour will position elements without automatic scrolling
        }

        function startChallengeMonitoring(challenge) {
            console.log('Starting challenge monitoring:', challenge.type);
            
            const targetElement = document.querySelector(challenge.target_element);
            if (!targetElement) {
                console.warn('Challenge target element not found:', challenge.target_element);
                // Auto-complete the challenge if element doesn't exist
                setTimeout(() => {
                    onChallengeCompleted(challenge);
                }, 1000);
                return;
            }
            
            // Add highlight to target element
            targetElement.classList.add('highlight-element');
            
            // Flag to prevent multiple completions
            let challengeCompleted = false;
            
            function checkChallenge() {
                // Exit early if challenge already completed
                if (challengeCompleted) {
                    return;
                }
                
                let completed = false;
                
                try {
                    switch (challenge.type) {
                        case 'range_target':
                            const currentValue = parseFloat(targetElement.value);
                            completed = Math.abs(currentValue - challenge.target_value) <= (challenge.tolerance || 0.1);
                            break;
                        case 'semiconductor_type':
                            completed = targetElement.value === challenge.target_value;
                            break;
                        case 'temperature_experiment':
                            const tempValue = parseFloat(targetElement.value);
                            completed = Math.abs(tempValue - challenge.target_value) <= (challenge.tolerance || 10);
                            break;
                        case 'tab_switch':
                            completed = currentTab === challenge.target_value || 
                                       (challenge.target_element.includes('biasing') && currentTab === 'biasing') ||
                                       (challenge.target_element.includes('applications') && currentTab === 'applications') ||
                                       (challenge.target_element.includes('challenges') && currentTab === 'challenges');
                            break;
                        case 'forward_bias':
                            const voltage = parseFloat(targetElement.value);
                            completed = voltage >= challenge.target_value - (challenge.tolerance || 0.05) && 
                                       voltage <= challenge.target_value + (challenge.tolerance || 0.05);
                            break;
                        case 'reverse_bias':
                            const revVoltage = parseFloat(targetElement.value);
                            completed = revVoltage <= challenge.target_value + (challenge.tolerance || 0.1) && 
                                       revVoltage >= challenge.target_value - (challenge.tolerance || 0.1);
                            break;
                        case 'application_demo':
                            completed = targetElement.value === challenge.target_value;
                            break;
                        case 'rectifier_demo':
                            completed = targetElement.value === challenge.target_value;
                            break;
                        case 'rectifier_comparison':
                            completed = targetElement.value === challenge.target_value;
                            break;
                        case 'capacitor_effect':
                            // Check if checkbox is checked for capacitor
                            completed = targetElement.checked === challenge.target_value;
                            break;
                        default:
                            // For unknown types, auto-complete after 3 seconds
                            setTimeout(() => {
                                if (!completed && !challengeCompleted) {
                                    challengeCompleted = true;
                                    onChallengeCompleted(challenge);
                                }
                            }, 3000);
                            break;
                    }
                } catch (error) {
                    console.warn('Error checking challenge:', error);
                    // Auto-complete if there's an error
                    setTimeout(() => {
                        if (!challengeCompleted) {
                            challengeCompleted = true;
                            onChallengeCompleted(challenge);
                        }
                    }, 1000);
                    return;
                }
                
                if (completed && !challengeCompleted) {
                    challengeCompleted = true;
                    onChallengeCompleted(challenge);
                } else if (!challengeCompleted) {
                    // Continue monitoring
                    setTimeout(checkChallenge, 500);
                }
            }
            
            // Start monitoring immediately
            setTimeout(checkChallenge, 100);
        }

        function onChallengeCompleted(challenge) {
            // Prevent duplicate completions
            if (window.currentChallengeCompleting) {
                return;
            }
            window.currentChallengeCompleting = true;
            
            console.log('Challenge completed!', challenge.type);
            
            // Clean up highlights
            cleanupTourHighlights();
            
            // Add success styling
            const targetElement = document.querySelector(challenge.target_element);
            if (targetElement) {
                targetElement.classList.add('challenge-success');
                setTimeout(() => {
                    targetElement.classList.remove('challenge-success');
                }, 1000);
            }
            
            // Update score
            tourScore += challenge.reward || 100;
            challengesSolvedInTour++;
            
            // Show achievement
            showAchievement({
                title: "Challenge Completed! 🎉",
                description: `You earned ${challenge.reward || 100} points!`,
                icon: "🏆"
            });
            
            // Auto-advance to next step after a delay
            setTimeout(() => {
                window.currentChallengeCompleting = false;
                nextTourStep();
            }, 2000);
        }

        function showHint() {
            const step = tourSteps[currentTourStep];
            if (step.challenge && step.challenge.hint) {
                hintsUsedInTour++;
                showAchievement({
                    title: "💡 Hint",
                    description: step.challenge.hint,
                    icon: "💡"
                });
                updateTourScore();
            }
        }

        function nextTourStep() {
            if (currentTourStep < tourSteps.length - 1) {
                currentTourStep++;
                showTourStep();
            } else {
                finalizeTour();
            }
        }

        function prevTourStep() {
            if (currentTourStep > 0) {
                currentTourStep--;
                showTourStep();
            }
        }

        function skipTour() {
            if (confirm('Are you sure you want to skip the guided tour?\n\nYou\'ll miss out on interactive challenges and detailed explanations about metal-semiconductor junctions. You can restart the tour anytime by clicking the "🎯 Start Tour" button.')) {
                finalizeTour();
            }
        }

        function finalizeTour() {
            console.log('Finalizing tour...');
            tourActive = false;
            
            // Hide tour elements
            document.getElementById('tourOverlay').classList.remove('active');
            document.getElementById('tourPopup').classList.remove('active');
            document.getElementById('tourScore').classList.remove('active');
            
            // Clean up highlights
            cleanupTourHighlights();
            
            // Show final achievement
            showAchievement({
                title: "🎓 Tour Complete!",
                description: `Congratulations! You scored ${tourScore} points and completed ${challengesSolvedInTour} challenges. You're now a metal-semiconductor junction expert!`,
                icon: "🎓"
            });
        }

        function showAchievement(achievement) {
            const achievementDiv = document.getElementById('tourAchievements');
            const titleElement = document.getElementById('achievementTitle');
            const descElement = document.getElementById('achievementDescription');
            
            titleElement.textContent = achievement.title;
            descElement.textContent = achievement.description;
            
            achievementDiv.classList.add('active');
        }

        function closeAchievement() {
            document.getElementById('tourAchievements').classList.remove('active');
        }

        function updateTourScore() {
            document.getElementById('tourScoreValue').textContent = tourScore;
            document.getElementById('stepsCompleted').textContent = `${currentTourStep + 1}/${tourSteps.length}`;
            document.getElementById('challengesCompleted').textContent = challengesSolvedInTour;
        }

        function cleanupTourHighlights() {
            // Remove all tour-related classes
            document.querySelectorAll('.highlight-element').forEach(el => {
                el.classList.remove('highlight-element');
            });
            document.querySelectorAll('.challenge-success').forEach(el => {
                el.classList.remove('challenge-success');
            });
        }

        // Enhanced tab switching to work with tour
        function switchTab(tabName) {
            console.log('Switching to tab:', tabName);
            
            // Update tab buttons
            document.querySelectorAll('.nav-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');
            
            // Update content
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            document.getElementById(tabName).classList.add('active');
            
            currentTab = tabName;
            
            // Initialize content based on tab
            switch(tabName) {
                case 'equilibrium':
                    updateEquilibriumVisualization();
                    break;
                case 'biasing':
                    updateBiasingVisualization();
                    break;
                case 'applications':
                    showHideApplicationControls();
                    updateApplicationVisualization();
                    // Auto-start simulation when switching to applications tab
                    setTimeout(() => {
                        console.log('Auto-starting simulation for applications tab...');
                        isDemoRunning = true;
                        window.capacitorVoltage = 0;
                        window.prevRectifierType = safeGetElement('rectifierType')?.value || 'half-wave';
                        window.prevCapacitorState = safeGetElement('addCapacitor')?.checked || false;
                        animateRectifier();
                    }, 200);
                    break;
                case 'challenges':
                    if (!selectedQuestions.rapidFire || selectedQuestions.rapidFire.length === 0) {
                        selectRandomQuestions();
                        generateChallengeContent();
                    }
                    break;
            }
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded, initializing simulation...');
            init();
            showHideApplicationControls();
            
            // Add click handlers for tab navigation
            document.querySelectorAll('.nav-tab').forEach(tab => {
                tab.addEventListener('click', function() {
                    const tabName = this.getAttribute('data-tab');
                    switchTab(tabName);
                });
            });
            
            // Start the guided tour automatically
            setTimeout(() => {
                startGuidedTour();
            }, 1000);
        });

        // Fallback initialization
        window.addEventListener('load', function() {
            console.log('Window loaded, ensuring simulation is initialized...');
            setTimeout(() => {
                init();
                showHideApplicationControls();
            }, 100);
        });

    </script>
</body>
</html>